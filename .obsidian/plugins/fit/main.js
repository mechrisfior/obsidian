/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FitPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// node_modules/@octokit/core/node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/index.js
function getUserAgent2() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent2()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/node_modules/universal-user-agent/index.js
function getUserAgent3() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    // Header values must be `string`
    headers: Object.fromEntries(
      Object.entries(requestOptions.headers).map(([name, value]) => [
        name,
        String(value)
      ])
    ),
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent3()}`
  }
});

// node_modules/@octokit/graphql/node_modules/universal-user-agent/index.js
function getUserAgent4() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent4()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.0.1";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// src/utils.ts
var import_obsidian = require("obsidian");
function getValueOrNull(obj, key) {
  return obj.hasOwnProperty(key) ? obj[key] : null;
}
function compareSha(currentShaMap, storedShaMap, env) {
  const determineStatus = (currentSha, storedSha) => {
    if (currentSha && storedSha && currentSha !== storedSha) {
      return env === "local" ? "changed" : "MODIFIED";
    } else if (currentSha && !storedSha) {
      return env === "local" ? "created" : "ADDED";
    } else if (!currentSha && storedSha) {
      return env === "local" ? "deleted" : "REMOVED";
    }
    return null;
  };
  return Object.keys({ ...currentShaMap, ...storedShaMap }).flatMap((path) => {
    const [currentSha, storedSha] = [getValueOrNull(currentShaMap, path), getValueOrNull(storedShaMap, path)];
    const status = determineStatus(currentSha, storedSha);
    if (status) {
      return [{
        path,
        status,
        currentSha: currentSha != null ? currentSha : void 0,
        extension: extractExtension(path)
      }];
    }
    return [];
  });
}
var RECOGNIZED_BINARY_EXT = ["png", "jpg", "jpeg", "pdf"];
function extractExtension(path) {
  var _a;
  return (_a = path.match(/[^.]+$/)) == null ? void 0 : _a[0];
}
function setEqual(arr1, arr2) {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  const isEqual = set1.size === set2.size && [...set1].every((value) => set2.has(value));
  return isEqual;
}
function removeLineEndingsFromBase64String(content) {
  return content.replace(/\r?\n|\r|\n/g, "");
}
function showFileOpsRecord(records) {
  console.log(records);
  if (records.length === 0 || records.every((r) => r.ops.length === 0)) {
    return;
  }
  const fileOpsNotice = new import_obsidian.Notice("", 0);
  records.map((recordSet) => {
    if (recordSet.ops.length === 0) {
      return;
    }
    const heading = fileOpsNotice.noticeEl.createEl("span", {
      cls: "file-changes-heading"
    });
    heading.setText(`${recordSet.heading}
`);
    const fileChanges = {
      created: [],
      changed: [],
      deleted: []
    };
    for (const op of recordSet.ops) {
      fileChanges[op.status].push(op.path);
    }
    for (const [changeType, paths] of Object.entries(fileChanges)) {
      if (paths.length === 0) {
        continue;
      }
      const heading2 = fileOpsNotice.noticeEl.createEl("span");
      heading2.setText(`${changeType.charAt(0).toUpperCase() + changeType.slice(1)}
`);
      heading2.addClass(`file-changes-subheading`);
      for (const path of paths) {
        const listItem = fileOpsNotice.noticeEl.createEl("li", {
          cls: "file-update-row"
        });
        listItem.setText(`${path}`);
        listItem.addClass(`file-${changeType}`);
      }
    }
  });
}
function showUnappliedConflicts(clashedFiles) {
  if (clashedFiles.length === 0) {
    return;
  }
  const localStatusMap = {
    created: "create",
    changed: "change",
    deleted: "delete"
  };
  const remoteStatusMap = {
    ADDED: "create",
    MODIFIED: "change",
    REMOVED: "delete"
  };
  const conflictNotice = new import_obsidian.Notice("", 0);
  const heading = conflictNotice.noticeEl.createEl("span");
  heading.setText(`Change conflicts:
`);
  heading.addClass(`file-changes-subheading`);
  const conflictStatus = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  conflictStatus.createDiv().setText("Local");
  conflictStatus.createDiv().setText("Remote");
  for (const clash of clashedFiles) {
    const conflictItem = conflictNotice.noticeEl.createDiv({
      cls: "file-conflict-row"
    });
    conflictItem.createDiv({
      cls: `file-conflict-${localStatusMap[clash.localStatus]}`
    });
    conflictItem.createDiv("div").setText(clash.path);
    conflictItem.createDiv({
      cls: `file-conflict-${remoteStatusMap[clash.remoteStatus]}`
    });
  }
  const footer = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  footer.setText("Note:");
  footer.style.fontWeight = "bold";
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText("Remote changes in _fit");
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText("_fit folder is overwritten on conflict, copy needed changes outside _fit.");
}

// src/fit.ts
var import_obsidian2 = require("obsidian");
var OctokitHttpError = class extends Error {
  constructor(message, status, source) {
    super(message);
    this.name = "HttpError";
    this.status = status;
    this.source = source;
  }
};
var Fit = class {
  constructor(setting, localStores, vaultOps) {
    this.loadSettings(setting);
    this.loadLocalStore(localStores);
    this.vaultOps = vaultOps;
    this.headers = {
      // Hack to disable caching which leads to inconsistency for
      // read after write https://github.com/octokit/octokit.js/issues/890
      "If-None-Match": "",
      "X-GitHub-Api-Version": "2022-11-28"
    };
  }
  loadSettings(setting) {
    this.owner = setting.owner;
    this.repo = setting.repo;
    this.branch = setting.branch;
    this.deviceName = setting.deviceName;
    this.octokit = new Octokit({ auth: setting.pat });
  }
  loadLocalStore(localStore) {
    this.localSha = localStore.localSha;
    this.lastFetchedCommitSha = localStore.lastFetchedCommitSha;
    this.lastFetchedRemoteSha = localStore.lastFetchedRemoteSha;
  }
  async fileSha1(fileContent) {
    const enc = new TextEncoder();
    const hashBuf = await crypto.subtle.digest("SHA-1", enc.encode(fileContent));
    const hashArray = Array.from(new Uint8Array(hashBuf));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  }
  async computeFileLocalSha(path) {
    const file = await this.vaultOps.getTFile(path);
    let content;
    if (RECOGNIZED_BINARY_EXT.includes(file.extension)) {
      content = (0, import_obsidian2.arrayBufferToBase64)(await this.vaultOps.vault.readBinary(file));
    } else {
      content = await this.vaultOps.vault.read(file);
    }
    return await this.fileSha1(path + content);
  }
  async computeLocalSha() {
    const paths = this.vaultOps.vault.getFiles().map((f) => {
      return f.path.startsWith("_fit/") ? null : f.path;
    }).filter(Boolean);
    return Object.fromEntries(
      await Promise.all(
        paths.map(async (p) => {
          return [p, await this.computeFileLocalSha(p)];
        })
      )
    );
  }
  async remoteUpdated() {
    const remoteCommitSha = await this.getLatestRemoteCommitSha();
    return { remoteCommitSha, updated: remoteCommitSha !== this.lastFetchedCommitSha };
  }
  async getLocalChanges(currentLocalSha) {
    if (!currentLocalSha) {
      currentLocalSha = await this.computeLocalSha();
    }
    const localChanges = compareSha(currentLocalSha, this.localSha, "local");
    return localChanges;
  }
  async getRemoteChanges(remoteTreeSha) {
    const remoteChanges = compareSha(remoteTreeSha, this.lastFetchedRemoteSha, "remote");
    return remoteChanges;
  }
  getClashedChanges(localChanges, remoteChanges) {
    const localChangePaths = localChanges.map((c) => c.path);
    const remoteChangePaths = remoteChanges.map((c) => c.path);
    const clashedFiles = localChangePaths.map(
      (path, localIndex) => {
        const remoteIndex = remoteChangePaths.indexOf(path);
        if (remoteIndex !== -1) {
          return { path, localIndex, remoteIndex };
        }
        return null;
      }
    ).filter(Boolean);
    return clashedFiles.map(
      ({ path, localIndex, remoteIndex }) => {
        return {
          path,
          localStatus: localChanges[localIndex].status,
          remoteStatus: remoteChanges[remoteIndex].status
        };
      }
    );
  }
  async getUser() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /user`,
        {
          headers: this.headers
        }
      );
      return { owner: response.login, avatarUrl: response.avatar_url };
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getUser");
    }
  }
  async getRepos() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /user/repos`,
        {
          affiliation: "owner",
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getBranches() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/branches`,
        {
          owner: this.owner,
          repo: this.repo,
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getRef(ref) {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/ref/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return response.object.sha;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRef");
    }
  }
  // Get the sha of the latest commit in the default branch (set by user in setting)
  async getLatestRemoteCommitSha(ref = `heads/${this.branch}`) {
    return await this.getRef(ref);
  }
  // ref Can be a commit SHA, branch name (heads/BRANCH_NAME), or tag name (tags/TAG_NAME), 
  // refers to https://git-scm.com/book/en/v2/Git-Internals-Git-References
  async getCommitTreeSha(ref) {
    const { data: commit } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/commits/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        headers: this.headers
      }
    );
    return commit.commit.tree.sha;
  }
  async getTree(tree_sha) {
    const { data: tree } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/trees/{tree_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        tree_sha,
        recursive: "true",
        headers: this.headers
      }
    );
    return tree.tree;
  }
  // get the remote tree sha in the format compatible with local store
  async getRemoteTreeSha(tree_sha) {
    const remoteTree = await this.getTree(tree_sha);
    const remoteSha = Object.fromEntries(remoteTree.map((node) => {
      if (node.type == "blob") {
        if (!node.path || !node.sha) {
          throw new Error("Path or sha not found for blob node in remote");
        }
        if (node.path.startsWith("_fit/")) {
          return null;
        }
        return [node.path, node.sha];
      }
      return null;
    }).filter(Boolean));
    return remoteSha;
  }
  async createBlob(content, encoding) {
    const { data: blob } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/blobs`,
      {
        owner: this.owner,
        repo: this.repo,
        content,
        encoding,
        headers: this.headers
      }
    );
    return blob.sha;
  }
  async createTreeNodeFromFile({ path, status, extension }, remoteTree) {
    if (status === "deleted") {
      if (remoteTree.every((node) => node.path !== path)) {
        return null;
      }
      return {
        path,
        mode: "100644",
        type: "blob",
        sha: null
      };
    }
    const file = await this.vaultOps.getTFile(path);
    let encoding;
    let content;
    if (extension && RECOGNIZED_BINARY_EXT.includes(extension)) {
      encoding = "base64";
      const fileArrayBuf = await this.vaultOps.vault.readBinary(file);
      const uint8Array = new Uint8Array(fileArrayBuf);
      let binaryString = "";
      for (let i = 0; i < uint8Array.length; i++) {
        binaryString += String.fromCharCode(uint8Array[i]);
      }
      content = btoa(binaryString);
    } else {
      encoding = "utf-8";
      content = await this.vaultOps.vault.read(file);
    }
    const blobSha = await this.createBlob(content, encoding);
    if (remoteTree.some((node) => node.path === path && node.sha === blobSha)) {
      return null;
    }
    return {
      path,
      mode: "100644",
      type: "blob",
      sha: blobSha
    };
  }
  async createTree(treeNodes, base_tree_sha) {
    const { data: newTree } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/trees`,
      {
        owner: this.owner,
        repo: this.repo,
        tree: treeNodes,
        base_tree: base_tree_sha,
        headers: this.headers
      }
    );
    return newTree.sha;
  }
  async createCommit(treeSha, parentSha) {
    const message = `Commit from ${this.deviceName} on ${new Date().toLocaleString()}`;
    const { data: createdCommit } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/commits`,
      {
        owner: this.owner,
        repo: this.repo,
        message,
        tree: treeSha,
        parents: [parentSha],
        headers: this.headers
      }
    );
    return createdCommit.sha;
  }
  async updateRef(sha, ref = `heads/${this.branch}`) {
    const { data: updatedRef } = await this.octokit.request(
      `PATCH /repos/{owner}/{repo}/git/refs/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        sha,
        headers: this.headers
      }
    );
    return updatedRef.object.sha;
  }
  async getBlob(file_sha) {
    const { data: blob } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/blobs/{file_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        file_sha,
        headers: this.headers
      }
    );
    return blob.content;
  }
};

// src/fitNotice.ts
var import_obsidian3 = require("obsidian");
var FitNotice = class {
  constructor(fit, addClasses = [], initialMessage, duration = 0, muted = false) {
    this.fit = fit;
    this.muted = muted;
    this.classes = ["fit-notice"];
    if (initialMessage && !this.muted) {
      this.show(initialMessage, addClasses, duration);
    } else {
      this.classes = [...this.classes, ...addClasses];
    }
  }
  mute() {
    this.muted = true;
    if (this.notice) {
      this.notice.hide();
    }
  }
  unmute() {
    this.muted = false;
  }
  show(initialMessage, addClasses = [], duration = 0) {
    if (!this.notice && !this.muted) {
      const message = initialMessage && initialMessage.length > 0 ? initialMessage : " ";
      this.notice = new import_obsidian3.Notice(message, duration);
      this.notice.noticeEl.addClasses([...this.classes, ...addClasses]);
    }
  }
  updateClasses(addClasses = [], removeClasses = []) {
    if (this.muted) {
      return;
    }
    this.classes = this.classes.filter((c) => !removeClasses.includes(c));
    if (this.notice) {
      this.notice.noticeEl.removeClasses(removeClasses);
      this.notice.noticeEl.addClasses(addClasses);
    }
    this.classes = [...this.classes, ...addClasses];
  }
  // allows error display to override muted
  setMessage(message, isError) {
    if (isError) {
      if (!this.notice) {
        this.notice = new import_obsidian3.Notice(message, 0);
        this.notice.noticeEl.addClasses(["fit-notice", "error"]);
      } else {
        this.notice.setMessage(message);
      }
    } else {
      if (this.notice && !this.muted) {
        this.notice.setMessage(message);
      }
    }
  }
  remove(finalClass, duration = 5e3) {
    var _a, _b, _c;
    if (this.muted) {
      return;
    }
    (_a = this.notice) == null ? void 0 : _a.noticeEl.removeClasses(this.classes.filter((c) => c !== "fit-notice"));
    if (finalClass) {
      (_b = this.notice) == null ? void 0 : _b.noticeEl.addClass(finalClass);
    } else {
      (_c = this.notice) == null ? void 0 : _c.noticeEl.addClass("done");
    }
    setTimeout(() => {
      var _a2;
      return (_a2 = this.notice) == null ? void 0 : _a2.hide();
    }, duration);
  }
};

// src/fitSetting.ts
var import_obsidian4 = require("obsidian");
var import_console = require("console");
var FitSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.getLatestLink = () => {
      const { owner, repo, branch } = this.plugin.settings;
      if (owner.length > 0 && repo.length > 0 && branch.length > 0) {
        return `https://github.com/${owner}/${repo}/tree/${branch}`;
      }
      return "";
    };
    this.handleUserFetch = async () => {
      this.authenticating = true;
      this.authUserAvatar.removeClass("error");
      this.authUserAvatar.empty();
      this.authUserAvatar.removeClass("empty");
      this.authUserAvatar.addClass("cat");
      try {
        const { owner, avatarUrl } = await this.plugin.fit.getUser();
        this.authUserAvatar.removeClass("cat");
        this.authUserAvatar.createEl("img", { attr: { src: avatarUrl } });
        this.authUserHandle.setText(owner);
        if (owner !== this.plugin.settings.owner) {
          this.plugin.settings.owner = owner;
          this.plugin.settings.avatarUrl = avatarUrl;
          this.plugin.settings.repo = "";
          this.plugin.settings.branch = "";
          this.existingBranches = [];
          this.existingRepos = [];
          await this.plugin.saveSettings();
          await this.refreshFields("repo(0)");
        }
        this.authenticating = false;
      } catch (error) {
        this.authUserAvatar.removeClass("cat");
        this.authUserAvatar.addClass("error");
        this.authUserHandle.setText("Authentication failed, make sure your token has not expired.");
        this.plugin.settings.owner = "";
        this.plugin.settings.avatarUrl = "";
        this.plugin.settings.repo = "";
        this.plugin.settings.branch = "";
        this.existingBranches = [];
        this.existingRepos = [];
        await this.plugin.saveSettings();
        this.refreshFields("initialize");
        this.authenticating = false;
      }
    };
    this.githubUserInfoBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setHeading().setName("GitHub user info").addButton((button) => button.setCta().setButtonText("Authenticate user").setDisabled(this.authenticating).onClick(async () => {
        if (this.authenticating)
          return;
        await this.handleUserFetch();
      }));
      this.ownerSetting = new import_obsidian4.Setting(containerEl).setDesc("Input your personal access token below to get authenticated. Create a GitHub account here if you don't have one yet.").addExtraButton((button) => button.setIcon("github").setTooltip("Sign up on github.com").onClick(async () => {
        window.open("https://github.com/signup", "_blank");
      }));
      this.ownerSetting.nameEl.addClass("fit-avatar-container");
      if (this.plugin.settings.owner === "") {
        this.authUserAvatar = this.ownerSetting.nameEl.createDiv(
          { cls: "fit-avatar-container empty" }
        );
        this.authUserHandle = this.ownerSetting.nameEl.createEl("span", { cls: "fit-github-handle" });
        this.authUserHandle.setText("Unauthenticated");
      } else {
        this.authUserAvatar = this.ownerSetting.nameEl.createDiv(
          { cls: "fit-avatar-container" }
        );
        this.authUserAvatar.createEl("img", { attr: { src: this.plugin.settings.avatarUrl } });
        this.authUserHandle = this.ownerSetting.nameEl.createEl("span", { cls: "fit-github-handle" });
        this.authUserHandle.setText(this.plugin.settings.owner);
      }
      this.ownerSetting.controlEl.addClass("fit-avatar-display-text");
      this.patSetting = new import_obsidian4.Setting(containerEl).setName("Github personal access token").setDesc("Remember to give it access for reading and writing to the storage repo.").addText((text) => text.setPlaceholder("GitHub personal access token").setValue(this.plugin.settings.pat).onChange(async (value) => {
        this.plugin.settings.pat = value;
        await this.plugin.saveSettings();
      })).addExtraButton((button) => button.setIcon("external-link").setTooltip("Create a token").onClick(async () => {
        window.open("https://github.com/settings/tokens/new", "_blank");
      }));
    };
    this.repoInfoBlock = async () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setHeading().setName("Repository info").setDesc("Refresh to retrieve the latest list of repos and branches.").addExtraButton((button) => button.setTooltip("Refresh repos and branches list").setDisabled(this.plugin.settings.owner === "").setIcon("refresh-cw").onClick(async () => {
        await this.refreshFields("repo(0)");
      }));
      new import_obsidian4.Setting(containerEl).setDesc("Select 'Add a README file' if creating a new repo. Make sure you are logged in to github on your browser.").addExtraButton((button) => button.setIcon("github").setTooltip("Create a new repository").onClick(() => {
        window.open(`https://github.com/new`, "_blank");
      }));
      this.repoSetting = new import_obsidian4.Setting(containerEl).setName("Github repository name").setDesc("Select a repo to sync your vault.").addDropdown((dropdown) => {
        dropdown.selectEl.addClass("repo-dropdown");
        this.existingRepos.map((repo) => dropdown.addOption(repo, repo));
        dropdown.setDisabled(this.existingRepos.length === 0);
        dropdown.setValue(this.plugin.settings.repo);
        dropdown.onChange(async (value) => {
          const repoChanged = value !== this.plugin.settings.repo;
          if (repoChanged) {
            this.plugin.settings.repo = value;
            await this.plugin.saveSettings();
            await this.refreshFields("branch(1)");
          }
        });
      });
      this.branchSetting = new import_obsidian4.Setting(containerEl).setName("Branch name").setDesc("Select a repo above to view existing branches.").addDropdown((dropdown) => {
        dropdown.selectEl.addClass("branch-dropdown");
        dropdown.setDisabled(this.existingBranches.length === 0);
        this.existingBranches.map((repo) => dropdown.addOption(repo, repo));
        dropdown.setValue(this.plugin.settings.branch);
        dropdown.onChange(async (value) => {
          const branchChanged = value !== this.plugin.settings.branch;
          if (branchChanged) {
            this.plugin.settings.branch = value;
            await this.plugin.saveSettings();
            await this.refreshFields("link(2)");
          }
        });
      });
      this.repoLink = this.getLatestLink();
      const linkDisplay = new import_obsidian4.Setting(containerEl).setName("View your vault on GitHub").setDesc(this.repoLink).addExtraButton(
        (button) => button.setDisabled(this.repoLink.length === 0).setTooltip("Open on GitHub").setIcon("external-link").onClick(() => {
          console.log(`opening ${this.repoLink}`);
          window.open(this.repoLink, "_blank");
        })
      );
      linkDisplay.descEl.addClass("link-desc");
    };
    this.localConfigBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setHeading().setName("Local configurations");
      new import_obsidian4.Setting(containerEl).setName("Device name").setDesc("Sign commit message with this device name.").addText((text) => text.setPlaceholder("Device name").setValue(this.plugin.settings.deviceName).onChange(async (value) => {
        this.plugin.settings.deviceName = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian4.Setting(containerEl).setName("Auto sync").setDesc(`Automatically sync your vault when remote has updates. (Muted: sync in the background without displaying notices, except for file changes and conflicts notice)`).addDropdown((dropdown) => {
        dropdown.addOption("off", "Off").addOption("muted", "Muted").addOption("remind", "Remind only").addOption("on", "On").setValue(this.plugin.settings.autoSync ? this.plugin.settings.autoSync : "off").onChange(async (value) => {
          this.plugin.settings.autoSync = value;
          checkIntervalSlider.settingEl.addClass(value === "off" ? "clear" : "restore");
          checkIntervalSlider.settingEl.removeClass(value === "off" ? "restore" : "clear");
          await this.plugin.saveSettings();
        });
      });
      const checkIntervalSlider = new import_obsidian4.Setting(containerEl).setName("Auto check interval").setDesc(`Automatically check for remote changes in the background every ${this.plugin.settings.checkEveryXMinutes} minutes.`).addSlider(
        (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.checkEveryXMinutes).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.checkEveryXMinutes = value;
          await this.plugin.saveSettings();
          checkIntervalSlider.setDesc(`Automatically check for remote changes in the background every ${value} minutes.`);
        })
      );
      if (this.plugin.settings.autoSync === "off") {
        checkIntervalSlider.settingEl.addClass("clear");
      }
    };
    this.noticeConfigBlock = () => {
      const { containerEl } = this;
      const selectedCol = "var(--interactive-accent)";
      const selectedTxtCol = "var(--text-on-accent)";
      const unselectedColor = "var(--interactive-normal)";
      const unselectedTxtCol = "var(--text-normal)";
      const stateTextMap = (notifyConflicts, notifyChanges) => {
        if (notifyConflicts && notifyChanges) {
          return "Displaying file changes and conflicts ";
        } else if (!notifyConflicts && notifyChanges) {
          return "Displaying file changes ";
        } else if (notifyConflicts && !notifyChanges) {
          return "Displaying change conflicts ";
        } else {
          return "No notice displayed ";
        }
      };
      const noticeDisplay = new import_obsidian4.Setting(containerEl).setName("Notice display").setDesc(`${stateTextMap(this.plugin.settings.notifyConflicts, this.plugin.settings.notifyChanges)} after sync.`);
      noticeDisplay.addButton((button) => {
        button.setButtonText("Change conflicts");
        button.onClick(async () => {
          const notifyConflicts = !this.plugin.settings.notifyConflicts;
          this.plugin.settings.notifyConflicts = notifyConflicts;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyConflicts ? selectedCol : unselectedColor,
            "color": notifyConflicts ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(notifyConflicts, this.plugin.settings.notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.settings.notifyConflicts ? selectedCol : unselectedColor,
          "color": this.plugin.settings.notifyConflicts ? selectedTxtCol : unselectedTxtCol
        });
      });
      noticeDisplay.addButton((button) => {
        button.setButtonText("File changes");
        button.onClick(async () => {
          const notifyChanges = !this.plugin.settings.notifyChanges;
          this.plugin.settings.notifyChanges = notifyChanges;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyChanges ? selectedCol : unselectedColor,
            "color": notifyChanges ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(this.plugin.settings.notifyConflicts, notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.settings.notifyChanges ? selectedCol : unselectedColor,
          "color": this.plugin.settings.notifyChanges ? selectedTxtCol : unselectedTxtCol
        });
      });
    };
    this.refreshFields = async (refreshFrom) => {
      const { containerEl } = this;
      const repo_dropdown = containerEl.querySelector(".repo-dropdown");
      const branch_dropdown = containerEl.querySelector(".branch-dropdown");
      const link_el = containerEl.querySelector(".link-desc");
      if (refreshFrom === "repo(0)") {
        repo_dropdown.disabled = true;
        branch_dropdown.disabled = true;
        this.existingRepos = await this.plugin.fit.getRepos();
        const repoOptions = Array.from(repo_dropdown.options).map((option) => option.value);
        if (!setEqual(this.existingRepos, repoOptions)) {
          repo_dropdown.empty();
          this.existingRepos.map((repo) => {
            repo_dropdown.add(new Option(repo, repo));
          });
          const selectedRepoIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
          repo_dropdown.selectedIndex = selectedRepoIndex;
          if (selectedRepoIndex === -1) {
            this.plugin.settings.repo = "";
          }
        }
        repo_dropdown.disabled = false;
      }
      if (refreshFrom === "branch(1)" || refreshFrom === "repo(0)") {
        if (this.plugin.settings.repo === "") {
          branch_dropdown.empty();
        } else {
          const latestBranches = await this.plugin.fit.getBranches();
          if (!setEqual(this.existingBranches, latestBranches)) {
            branch_dropdown.empty();
            this.existingBranches = latestBranches;
            this.existingBranches.map((branch) => {
              branch_dropdown.add(new Option(branch, branch));
            });
            const selectedBranchIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
            branch_dropdown.selectedIndex = selectedBranchIndex;
            if (selectedBranchIndex === -1) {
              this.plugin.settings.branch = "";
            }
          }
        }
        branch_dropdown.disabled = false;
      }
      if (refreshFrom === "link(2)" || refreshFrom === "branch(1)" || refreshFrom === "repo(0)") {
        this.repoLink = this.getLatestLink();
        link_el.innerText = this.repoLink;
      }
      if (refreshFrom === "initialize") {
        const { repo, branch } = this.plugin.settings;
        repo_dropdown.empty();
        branch_dropdown.empty();
        repo_dropdown.add(new Option(repo, repo));
        branch_dropdown.add(new Option(branch, branch));
        link_el.innerText = this.getLatestLink();
      }
      if (refreshFrom === "withCache") {
        repo_dropdown.empty();
        branch_dropdown.empty();
        if (this.existingRepos.length > 0) {
          this.existingRepos.map((repo) => {
            repo_dropdown.add(new Option(repo, repo));
          });
          repo_dropdown.selectedIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
        }
        if (this.existingBranches.length > 0) {
          this.existingBranches.map((branch) => {
            branch_dropdown.add(new Option(branch, branch));
          });
          if (this.plugin.settings.branch === "") {
            branch_dropdown.selectedIndex = -1;
          }
          branch_dropdown.selectedIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
        }
        if (this.plugin.settings.repo !== "") {
          if (this.existingRepos.length === 0) {
            repo_dropdown.add(new Option(this.plugin.settings.repo, this.plugin.settings.repo));
          } else {
            repo_dropdown.selectedIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
            if (branch_dropdown.selectedIndex === -1) {
              (0, import_console.warn)(`warning: selected branch ${this.plugin.settings.branch} not found, existing branches: ${this.existingBranches}`);
            }
          }
        }
        if (this.plugin.settings.branch !== "") {
          if (this.existingBranches.length === 0) {
            branch_dropdown.add(new Option(this.plugin.settings.branch, this.plugin.settings.branch));
          } else {
            branch_dropdown.selectedIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
            if (branch_dropdown.selectedIndex === -1) {
              (0, import_console.warn)(`warning: selected branch ${this.plugin.settings.branch} not found, existing branches: ${this.existingBranches}`);
            }
          }
        }
      }
    };
    this.plugin = plugin;
    this.repoLink = this.getLatestLink();
    this.authenticating = false;
    this.existingRepos = [];
    this.existingBranches = [];
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.githubUserInfoBlock();
    this.repoInfoBlock();
    this.localConfigBlock();
    this.noticeConfigBlock();
    this.refreshFields("withCache");
  }
};

// src/fitSync.ts
var import_obsidian5 = require("obsidian");

// src/fitPull.ts
var FitPull = class {
  constructor(fit) {
    this.fit = fit;
  }
  async performPrePullChecks(localChanges) {
    const { remoteCommitSha, updated } = await this.fit.remoteUpdated();
    if (!updated) {
      return { status: "localCopyUpToDate", remoteUpdate: null };
    }
    if (!localChanges) {
      localChanges = await this.fit.getLocalChanges();
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    const clashedFiles = this.fit.getClashedChanges(localChanges, remoteChanges);
    const prePullCheckStatus = remoteChanges.length > 0 ? clashedFiles.length > 0 ? "localChangesClashWithRemoteChanges" : "remoteChangesCanBeMerged" : "noRemoteChangesDetected";
    return {
      status: prePullCheckStatus,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles
      }
    };
  }
  // Get changes from remote, pathShaMap is coupled to the Fit plugin design
  async getRemoteNonDeletionChangesContent(pathShaMap) {
    const remoteChanges = Object.entries(pathShaMap).map(async ([path, file_sha]) => {
      const content = await this.fit.getBlob(file_sha);
      return { path, content };
    });
    return await Promise.all(remoteChanges);
  }
  async prepareChangesToExecute(remoteChanges) {
    const deleteFromLocal = remoteChanges.filter((c) => c.status == "REMOVED").map((c) => c.path);
    const changesToProcess = remoteChanges.filter((c) => c.status != "REMOVED").reduce(
      (acc, change) => {
        acc[change.path] = change.currentSha;
        return acc;
      },
      {}
    );
    const addToLocal = await this.getRemoteNonDeletionChangesContent(changesToProcess);
    return { addToLocal, deleteFromLocal };
  }
  async pullRemoteToLocal(remoteUpdate, saveLocalStoreCallback) {
    const { remoteChanges, remoteTreeSha, latestRemoteCommitSha } = remoteUpdate;
    const { addToLocal, deleteFromLocal } = await this.prepareChangesToExecute(remoteChanges);
    const fileOpsRecord = await this.fit.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await saveLocalStoreCallback({
      lastFetchedRemoteSha: remoteTreeSha,
      lastFetchedCommitSha: latestRemoteCommitSha,
      localSha: await this.fit.computeLocalSha()
    });
    return fileOpsRecord;
  }
};

// src/fitPush.ts
var FitPush = class {
  constructor(fit) {
    this.fit = fit;
  }
  async createCommitFromLocalUpdate(localUpdate, remoteTree) {
    const { localChanges, parentCommitSha } = localUpdate;
    const pushedChanges = [];
    const treeNodes = (await Promise.all(localChanges.map(async (f, i) => {
      const node = await this.fit.createTreeNodeFromFile(f, remoteTree);
      if (node) {
        pushedChanges.push(localChanges[i]);
        return node;
      }
    }))).filter(Boolean);
    console.log(treeNodes);
    if (treeNodes.length === 0) {
      return null;
    }
    const latestRemoteCommitTreeSha = await this.fit.getCommitTreeSha(parentCommitSha);
    const createdTreeSha = await this.fit.createTree(treeNodes, latestRemoteCommitTreeSha);
    const createdCommitSha = await this.fit.createCommit(createdTreeSha, parentCommitSha);
    return { createdCommitSha, pushedChanges };
  }
  async pushChangedFilesToRemote(localUpdate) {
    if (localUpdate.localChanges.length == 0) {
      return null;
    }
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.createCommitFromLocalUpdate(localUpdate, remoteTree);
    if (!createCommitResult) {
      return null;
    }
    const { createdCommitSha, pushedChanges } = createCommitResult;
    const updatedRefSha = await this.fit.updateRef(createdCommitSha);
    const updatedRemoteTreeSha = await this.fit.getRemoteTreeSha(updatedRefSha);
    return {
      pushedChanges,
      lastFetchedRemoteSha: updatedRemoteTreeSha,
      lastFetchedCommitSha: createdCommitSha
    };
  }
};

// src/fitSync.ts
var FitSync = class {
  constructor(fit, vaultOps, saveLocalStoreCallback) {
    this.fit = fit;
    this.fitPull = new FitPull(fit);
    this.fitPush = new FitPush(fit);
    this.vaultOps = vaultOps;
    this.saveLocalStoreCallback = saveLocalStoreCallback;
  }
  async performPreSyncChecks() {
    const currentLocalSha = await this.fit.computeLocalSha();
    const localChanges = await this.fit.getLocalChanges(currentLocalSha);
    const { remoteCommitSha, updated: remoteUpdated } = await this.fit.remoteUpdated();
    if (localChanges.length === 0 && !remoteUpdated) {
      return { status: "inSync" };
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    let clashes = [];
    let status;
    if (localChanges.length > 0 && !remoteUpdated) {
      status = "onlyLocalChanged";
    } else if (remoteUpdated && localChanges.length === 0 && remoteChanges.length === 0) {
      status = "onlyRemoteCommitShaChanged";
    } else if (localChanges.length === 0 && remoteUpdated) {
      status = "onlyRemoteChanged";
    } else {
      clashes = this.fit.getClashedChanges(localChanges, remoteChanges);
      if (clashes.length === 0) {
        status = "localAndRemoteChangesCompatible";
      } else {
        status = "localAndRemoteChangesClashed";
      }
    }
    return {
      status,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles: clashes
      },
      localChanges,
      localTreeSha: currentLocalSha
    };
  }
  generateConflictReport(path, localContent, remoteContent) {
    const detectedExtension = extractExtension(path);
    if (detectedExtension && RECOGNIZED_BINARY_EXT.includes(detectedExtension)) {
      return {
        path,
        resolutionStrategy: "binary",
        remoteContent
      };
    }
    return {
      path,
      resolutionStrategy: "utf-8",
      localContent,
      remoteContent
    };
  }
  async handleBinaryConflict(path, remoteContent) {
    const conflictResolutionFolder = "_fit";
    const conflictResolutionPath = `${conflictResolutionFolder}/${path}`;
    await this.fit.vaultOps.ensureFolderExists(conflictResolutionPath);
    await this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteContent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleUTF8Conflict(path, localContent, remoteConent) {
    const conflictResolutionFolder = "_fit";
    const conflictResolutionPath = `${conflictResolutionFolder}/${path}`;
    this.fit.vaultOps.ensureFolderExists(conflictResolutionPath);
    this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteConent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleLocalDeletionConflict(path, remoteContent) {
    const conflictResolutionFolder = "_fit";
    this.fit.vaultOps.ensureFolderExists(conflictResolutionFolder);
    const conflictResolutionPath = `${conflictResolutionFolder}/${path}`;
    this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteContent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async resolveFileConflict(clash, latestRemoteFileSha) {
    if (clash.localStatus === "deleted" && clash.remoteStatus === "REMOVED") {
      return { path: clash.path, noDiff: true };
    } else if (clash.localStatus === "deleted") {
      const remoteContent = await this.fit.getBlob(latestRemoteFileSha);
      const fileOp = await this.handleLocalDeletionConflict(clash.path, remoteContent);
      return { path: clash.path, noDiff: false, fileOp };
    }
    const localFile = await this.fit.vaultOps.getTFile(clash.path);
    const localFileContent = (0, import_obsidian5.arrayBufferToBase64)(await this.fit.vaultOps.vault.readBinary(localFile));
    if (latestRemoteFileSha) {
      const remoteContent = await this.fit.getBlob(latestRemoteFileSha);
      if (removeLineEndingsFromBase64String(remoteContent) !== removeLineEndingsFromBase64String(localFileContent)) {
        const report = this.generateConflictReport(clash.path, localFileContent, remoteContent);
        let fileOp;
        if (report.resolutionStrategy === "binary") {
          fileOp = await this.handleBinaryConflict(clash.path, report.remoteContent);
        } else {
          fileOp = await this.handleUTF8Conflict(clash.path, report.localContent, report.remoteContent);
        }
        return { path: clash.path, noDiff: false, fileOp };
      }
      return { path: clash.path, noDiff: true };
    } else {
      return { path: clash.path, noDiff: false };
    }
  }
  async resolveConflicts(clashedFiles, latestRemoteTreeSha) {
    const fileResolutions = await Promise.all(
      clashedFiles.map((clash) => {
        return this.resolveFileConflict(clash, latestRemoteTreeSha[clash.path]);
      })
    );
    const unresolvedFiles = fileResolutions.map((res, i) => {
      if (!res.noDiff) {
        return clashedFiles[i];
      }
      return null;
    }).filter(Boolean);
    return {
      noConflict: fileResolutions.every((res) => res.noDiff),
      unresolvedFiles,
      fileOpsRecord: fileResolutions.map((r) => r.fileOp).filter(Boolean)
    };
  }
  async syncCompatibleChanges(localUpdate, remoteUpdate, syncNotice) {
    const { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(
      remoteUpdate.remoteChanges
    );
    syncNotice.setMessage("Uploading local changes");
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.fitPush.createCommitFromLocalUpdate(localUpdate, remoteTree);
    let latestRemoteTreeSha;
    let latestCommitSha;
    let pushedChanges;
    if (createCommitResult) {
      const { createdCommitSha } = createCommitResult;
      const latestRefSha = await this.fit.updateRef(createdCommitSha);
      latestRemoteTreeSha = await this.fit.getRemoteTreeSha(latestRefSha);
      latestCommitSha = createdCommitSha;
      pushedChanges = createCommitResult.pushedChanges;
    } else {
      latestRemoteTreeSha = remoteUpdate.remoteTreeSha;
      latestCommitSha = remoteUpdate.latestRemoteCommitSha;
      pushedChanges = [];
    }
    syncNotice.setMessage("Writing remote changes to local");
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await this.saveLocalStoreCallback({
      lastFetchedRemoteSha: latestRemoteTreeSha,
      lastFetchedCommitSha: latestCommitSha,
      localSha: await this.fit.computeLocalSha()
    });
    syncNotice.setMessage("Sync successful");
    return { localOps: localFileOpsRecord, remoteOps: pushedChanges };
  }
  async syncWithConflicts(localChanges, remoteUpdate, syncNotice) {
    const { latestRemoteCommitSha, clashedFiles, remoteTreeSha: latestRemoteTreeSha } = remoteUpdate;
    const { noConflict, unresolvedFiles, fileOpsRecord } = await this.resolveConflicts(clashedFiles, latestRemoteTreeSha);
    let localChangesToPush;
    let remoteChangesToWrite;
    if (noConflict) {
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !localChanges.some((l) => l.path === c.path));
      localChangesToPush = localChanges.filter((c) => !remoteUpdate.remoteChanges.some((r) => r.path === c.path));
    } else {
      syncNotice.setMessage(`Change conflicts detected`);
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !unresolvedFiles.some((l) => l.path === c.path));
      localChangesToPush = localChanges;
    }
    const { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(remoteChangesToWrite);
    const syncLocalUpdate = {
      localChanges: localChangesToPush,
      parentCommitSha: latestRemoteCommitSha
    };
    const pushResult = await this.fitPush.pushChangedFilesToRemote(syncLocalUpdate);
    let pushedChanges;
    let lastFetchedCommitSha;
    let lastFetchedRemoteSha;
    if (pushResult) {
      pushedChanges = pushResult.pushedChanges;
      lastFetchedCommitSha = pushResult.lastFetchedCommitSha;
      lastFetchedRemoteSha = pushResult.lastFetchedRemoteSha;
    } else {
      pushedChanges = [];
      lastFetchedCommitSha = remoteUpdate.latestRemoteCommitSha;
      lastFetchedRemoteSha = remoteUpdate.remoteTreeSha;
    }
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await this.saveLocalStoreCallback({
      lastFetchedRemoteSha,
      lastFetchedCommitSha,
      localSha: await this.fit.computeLocalSha()
    });
    const ops = localFileOpsRecord.concat(fileOpsRecord);
    if (unresolvedFiles.length === 0) {
      syncNotice.setMessage(`Sync successful`);
    } else if (unresolvedFiles.some((f) => f.remoteStatus !== "REMOVED")) {
      syncNotice.setMessage(`Synced with remote, unresolved conflicts written to _fit`);
    } else {
      syncNotice.setMessage(`Synced with remote, ignored remote deletion of locally changed files`);
    }
    return { unresolvedFiles, localOps: ops, remoteOps: pushedChanges };
  }
  async sync(syncNotice) {
    syncNotice.setMessage("Performing pre sync checks.");
    const preSyncCheckResult = await this.performPreSyncChecks();
    if (preSyncCheckResult.status === "inSync") {
      syncNotice.setMessage("Sync successful");
      return;
    }
    if (preSyncCheckResult.status === "onlyRemoteCommitShaChanged") {
      const { latestRemoteCommitSha } = preSyncCheckResult.remoteUpdate;
      await this.saveLocalStoreCallback({ lastFetchedCommitSha: latestRemoteCommitSha });
      syncNotice.setMessage("Sync successful");
      return;
    }
    const remoteUpdate = preSyncCheckResult.remoteUpdate;
    if (preSyncCheckResult.status === "onlyRemoteChanged") {
      const fileOpsRecord = await this.fitPull.pullRemoteToLocal(remoteUpdate, this.saveLocalStoreCallback);
      syncNotice.setMessage("Sync successful");
      return { ops: [{ heading: "Local file updates:", ops: fileOpsRecord }], clash: [] };
    }
    const { localChanges, localTreeSha } = preSyncCheckResult;
    const localUpdate = {
      localChanges,
      parentCommitSha: remoteUpdate.latestRemoteCommitSha
    };
    if (preSyncCheckResult.status === "onlyLocalChanged") {
      syncNotice.setMessage("Uploading local changes");
      const pushResult = await this.fitPush.pushChangedFilesToRemote(localUpdate);
      syncNotice.setMessage("Sync successful");
      if (pushResult) {
        await this.saveLocalStoreCallback({
          localSha: localTreeSha,
          lastFetchedRemoteSha: pushResult.lastFetchedRemoteSha,
          lastFetchedCommitSha: pushResult.lastFetchedCommitSha
        });
        return { ops: [{ heading: "Local file updates:", ops: pushResult.pushedChanges }], clash: [] };
      }
      return;
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesCompatible") {
      const { localOps, remoteOps } = await this.syncCompatibleChanges(
        localUpdate,
        remoteUpdate,
        syncNotice
      );
      return {
        ops: [
          { heading: "Local file updates:", ops: localOps },
          { heading: "Remote file updates:", ops: remoteOps }
        ],
        clash: []
      };
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesClashed") {
      const conflictResolutionResult = await this.syncWithConflicts(
        localUpdate.localChanges,
        remoteUpdate,
        syncNotice
      );
      if (conflictResolutionResult) {
        const { unresolvedFiles, localOps, remoteOps } = conflictResolutionResult;
        return {
          ops: [
            { heading: "Local file updates:", ops: localOps },
            { heading: "Remote file updates:", ops: remoteOps }
          ],
          clash: unresolvedFiles
        };
      }
    }
  }
};

// src/vaultOps.ts
var import_obsidian6 = require("obsidian");
var VaultOperations = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getTFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      return file;
    } else {
      throw new Error(`Attempting to read ${path} from local drive as TFile but not successful,
            file is of type ${typeof file}.`);
    }
  }
  async deleteFromLocal(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      await this.vault.delete(file);
      return { path, status: "deleted" };
    }
    throw new Error(`Attempting to delete ${path} from local but not successful, file is of type ${typeof file}.`);
  }
  // if checking a folder, require including the last / in the path param
  async ensureFolderExists(path) {
    var _a;
    const folderPath = ((_a = path.match(/^(.*)\//)) == null ? void 0 : _a[1]) || "";
    if (folderPath != "") {
      const folder = this.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await this.vault.createFolder(folderPath);
      }
    }
  }
  async writeToLocal(path, content) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      await this.vault.modifyBinary(file, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "changed" };
    } else if (!file) {
      this.ensureFolderExists(path);
      await this.vault.createBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "created" };
    }
    throw new Error(`${path} writeToLocal operation unsuccessful, vault abstractFile on ${path} is of type ${typeof file}`);
  }
  async updateLocalFiles(addToLocal, deleteFromLocal) {
    const writeOperations = addToLocal.map(async ({ path, content }) => {
      return await this.writeToLocal(path, content);
    });
    const deletionOperations = deleteFromLocal.map(async (path) => {
      return await this.deleteFromLocal(path);
    });
    const fileOps = await Promise.all([...writeOperations, ...deletionOperations]);
    return fileOps;
  }
  async createCopyInDir(path, copyDir = "_fit") {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      const copy = await this.vault.readBinary(file);
      const copyPath = `${copyDir}/${path}`;
      this.ensureFolderExists(copyPath);
      const copyFile = this.vault.getAbstractFileByPath(path);
      if (copyFile && copyFile instanceof import_obsidian6.TFile) {
        await this.vault.modifyBinary(copyFile, copy);
      } else if (!copyFile) {
        await this.vault.createBinary(copyPath, copy);
      } else {
        this.vault.delete(copyFile, true);
        await this.vault.createBinary(copyPath, copy);
      }
      await this.vault.createBinary(copyPath, copy);
    } else {
      throw new Error(`Attempting to create copy of ${path} from local drive as TFile but not successful,
            file is of type ${typeof file}.`);
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  pat: "",
  owner: "",
  avatarUrl: "",
  repo: "",
  branch: "",
  deviceName: "",
  checkEveryXMinutes: 5,
  autoSync: "off",
  notifyChanges: true,
  notifyConflicts: true
};
var DEFAULT_LOCAL_STORE = {
  localSha: {},
  lastFetchedCommitSha: null,
  lastFetchedRemoteSha: {}
};
var FitPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    // use of arrow functions to ensure this refers to the FitPlugin class
    this.saveLocalStoreCallback = async (localStore) => {
      await this.loadLocalStore();
      this.localStore = { ...this.localStore, ...localStore };
      await this.saveLocalStore();
    };
    this.sync = async (syncNotice) => {
      if (!this.checkSettingsConfigured()) {
        return;
      }
      await this.loadLocalStore();
      const syncRecords = await this.fitSync.sync(syncNotice);
      if (syncRecords) {
        const { ops, clash } = syncRecords;
        if (this.settings.notifyConflicts) {
          showUnappliedConflicts(clash);
        }
        if (this.settings.notifyChanges) {
          showFileOpsRecord(ops);
        }
      }
    };
    // wrapper to convert error to notice, return true if error is caught
    this.catchErrorAndNotify = async (func, notice, ...args) => {
      try {
        const result = await func(notice, ...args);
        return result;
      } catch (error) {
        if (error instanceof OctokitHttpError) {
          console.log("error.status");
          console.log(error.status);
          switch (error.source) {
            case "getTree":
            case "getRef":
              console.error("Caught error from getRef: ", error.message);
              if (error.status === 404) {
                notice.setMessage("Failed to get ref, make sure your repo name and branch name are set correctly.", true);
                return true;
              }
              notice.setMessage("Unknown error in getting ref, refers to console for details.", true);
              return true;
            case "getCommitTreeSha":
            case "getRemoteTreeSha":
            case "createBlob":
            case "createTreeNodeFromFile":
            case "createCommit":
            case "updateRef":
            case "getBlob":
          }
          return true;
        }
        console.error("Caught unknown error: ", error);
        notice.setMessage("Unable to sync, if you are not connected to the internet, turn off auto sync.", true);
        return true;
      }
    };
  }
  // if settings not configured, open settings to let user quickly setup
  // Note: this is not a stable feature and might be disabled at any point in the future
  openPluginSettings() {
    const appWithSetting = this.app;
    appWithSetting.setting.open();
    appWithSetting.setting.openTabById("fit");
  }
  checkSettingsConfigured() {
    const actionItems = [];
    if (this.settings.pat === "") {
      actionItems.push("provide GitHub personal access token");
    }
    if (this.settings.owner === "") {
      actionItems.push("authenticate with personal access token");
    }
    if (this.settings.repo === "") {
      actionItems.push("select a repository to sync to");
    }
    if (this.settings.branch === "") {
      actionItems.push("select a branch to sync to");
    }
    if (actionItems.length > 0) {
      const initialMessage = "Settings not configured, please complete the following action items:\n" + actionItems.join("\n");
      const settingsNotice = new FitNotice(this.fit, ["static"], initialMessage);
      this.openPluginSettings();
      settingsNotice.remove("static");
      return false;
    }
    this.fit.loadSettings(this.settings);
    return true;
  }
  loadRibbonIcons() {
    this.fitSyncRibbonIconEl = this.addRibbonIcon("github", "Fit Sync", async (evt) => {
      if (this.syncing || this.autoSyncing) {
        return;
      }
      this.syncing = true;
      this.fitSyncRibbonIconEl.addClass("animate-icon");
      const syncNotice = new FitNotice(this.fit, ["loading"], "Initiating sync");
      const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        syncNotice.remove("error");
        this.syncing = false;
        return;
      }
      syncNotice.remove("done");
      this.syncing = false;
    });
    this.fitSyncRibbonIconEl.addClass("fit-sync-ribbon-el");
  }
  async autoSync() {
    if (this.syncing || this.autoSyncing) {
      return;
    }
    this.autoSyncing = true;
    const syncNotice = new FitNotice(
      this.fit,
      ["loading"],
      "Auto syncing",
      0,
      this.settings.autoSync === "muted"
    );
    const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
    if (errorCaught === true) {
      syncNotice.remove("error");
    } else {
      syncNotice.remove();
    }
    this.autoSyncing = false;
  }
  async autoUpdate() {
    if (!(this.settings.autoSync === "off") && !this.syncing && !this.autoSyncing && this.checkSettingsConfigured()) {
      if (this.settings.autoSync === "on" || this.settings.autoSync === "muted") {
        await this.autoSync();
      } else if (this.settings.autoSync === "remind") {
        const { updated } = await this.fit.remoteUpdated();
        if (updated) {
          const initialMessage = "Remote update detected, please pull the latest changes.";
          const intervalNotice = new FitNotice(this.fit, ["static"], initialMessage);
          intervalNotice.remove("static");
        }
      }
    }
  }
  async startOrUpdateAutoSyncInterval() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
    this.autoSyncIntervalId = window.setInterval(async () => {
      await this.autoUpdate();
    }, this.settings.checkEveryXMinutes * 60 * 1e3);
  }
  async onload() {
    await this.loadSettings();
    await this.loadLocalStore();
    this.vaultOps = new VaultOperations(this.app.vault);
    this.fit = new Fit(this.settings, this.localStore, this.vaultOps);
    this.fitSync = new FitSync(this.fit, this.vaultOps, this.saveLocalStoreCallback);
    this.syncing = false;
    this.autoSyncing = false;
    this.settingTab = new FitSettingTab(this.app, this);
    this.loadRibbonIcons();
    this.addSettingTab(new FitSettingTab(this.app, this));
    await this.startOrUpdateAutoSyncInterval();
  }
  onunload() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
  }
  async loadSettings() {
    const userSetting = await this.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, userSetting);
    const settingsObj = Object.keys(DEFAULT_SETTINGS).reduce(
      (obj, key) => {
        if (settings.hasOwnProperty(key)) {
          if (key == "checkEveryXMinutes") {
            obj[key] = Number(settings[key]);
          } else if (key === "notifyChanges" || key === "notifyConflicts") {
            obj[key] = Boolean(settings[key]);
          } else {
            obj[key] = settings[key];
          }
        }
        return obj;
      },
      {}
    );
    this.settings = settingsObj;
  }
  async loadLocalStore() {
    const localStore = Object.assign({}, DEFAULT_LOCAL_STORE, await this.loadData());
    const localStoreObj = Object.keys(DEFAULT_LOCAL_STORE).reduce(
      (obj, key) => {
        if (localStore.hasOwnProperty(key)) {
          obj[key] = localStore[key];
        }
        return obj;
      },
      {}
    );
    this.localStore = localStoreObj;
  }
  // allow saving of local stores property, passed in properties will override existing stored value
  async saveLocalStore() {
    const data = Object.assign({}, DEFAULT_LOCAL_STORE, await this.loadData());
    await this.saveData({ ...data, ...this.localStore });
    this.fit.loadLocalStore(this.localStore);
  }
  async saveSettings() {
    const data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    await this.saveData({ ...data, ...this.settings });
    this.startOrUpdateAutoSyncInterval();
    this.fit.loadSettings(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9yZWdpc3Rlci5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL2FkZC5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL3JlbW92ZS5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2VuZHBvaW50L25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZW5kcG9pbnQvZGlzdC1idW5kbGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3VuaXZlcnNhbC11c2VyLWFnZW50L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0LWVycm9yL2Rpc3Qtc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L2Rpc3QtYnVuZGxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9ncmFwaHFsL25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZ3JhcGhxbC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvYXV0aC10b2tlbi9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9kaXN0LXNyYy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9jb3JlL2Rpc3Qtc3JjL2luZGV4LmpzIiwgInNyYy91dGlscy50cyIsICJzcmMvZml0LnRzIiwgInNyYy9maXROb3RpY2UudHMiLCAic3JjL2ZpdFNldHRpbmcudHMiLCAic3JjL2ZpdFN5bmMudHMiLCAic3JjL2ZpdFB1bGwudHMiLCAic3JjL2ZpdFB1c2gudHMiLCAic3JjL3ZhdWx0T3BzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBQbHVnaW4sIFNldHRpbmdUYWIgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBGaXQsIE9jdG9raXRIdHRwRXJyb3IgfSBmcm9tICdzcmMvZml0JztcbmltcG9ydCBGaXROb3RpY2UgZnJvbSAnc3JjL2ZpdE5vdGljZSc7XG5pbXBvcnQgRml0U2V0dGluZ1RhYiBmcm9tICdzcmMvZml0U2V0dGluZyc7XG5pbXBvcnQgeyBGaXRTeW5jIH0gZnJvbSAnc3JjL2ZpdFN5bmMnO1xuaW1wb3J0IHsgc2hvd0ZpbGVPcHNSZWNvcmQsIHNob3dVbmFwcGxpZWRDb25mbGljdHMgfSBmcm9tICdzcmMvdXRpbHMnO1xuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSAnc3JjL3ZhdWx0T3BzJztcblxuZXhwb3J0IGludGVyZmFjZSBGaXRTZXR0aW5ncyB7XG5cdHBhdDogc3RyaW5nO1xuXHRvd25lcjogc3RyaW5nO1xuXHRhdmF0YXJVcmw6IHN0cmluZztcblx0cmVwbzogc3RyaW5nO1xuXHRicmFuY2g6IHN0cmluZztcblx0ZGV2aWNlTmFtZTogc3RyaW5nO1xuXHRjaGVja0V2ZXJ5WE1pbnV0ZXM6IG51bWJlclxuXHRhdXRvU3luYzogXCJvblwiIHwgXCJvZmZcIiB8IFwibXV0ZWRcIiB8IFwicmVtaW5kXCJcblx0bm90aWZ5Q2hhbmdlczogYm9vbGVhblxuXHRub3RpZnlDb25mbGljdHM6IGJvb2xlYW5cbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogRml0U2V0dGluZ3MgPSB7XG5cdHBhdDogXCJcIixcblx0b3duZXI6IFwiXCIsXG5cdGF2YXRhclVybDogXCJcIixcblx0cmVwbzogXCJcIixcblx0YnJhbmNoOiBcIlwiLFxuXHRkZXZpY2VOYW1lOiBcIlwiLFxuXHRjaGVja0V2ZXJ5WE1pbnV0ZXM6IDUsXG5cdGF1dG9TeW5jOiBcIm9mZlwiLFxuXHRub3RpZnlDaGFuZ2VzOiB0cnVlLFxuXHRub3RpZnlDb25mbGljdHM6IHRydWVcdFxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxTdG9yZXMge1xuXHRsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXHRsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nIHwgbnVsbFxuXHRsYXN0RmV0Y2hlZFJlbW90ZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxufVxuXG5jb25zdCBERUZBVUxUX0xPQ0FMX1NUT1JFOiBMb2NhbFN0b3JlcyA9IHtcblx0bG9jYWxTaGE6IHt9LFxuXHRsYXN0RmV0Y2hlZENvbW1pdFNoYTogbnVsbCxcblx0bGFzdEZldGNoZWRSZW1vdGVTaGE6IHt9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml0UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IEZpdFNldHRpbmdzO1xuXHRzZXR0aW5nVGFiOiBGaXRTZXR0aW5nVGFiXG5cdGxvY2FsU3RvcmU6IExvY2FsU3RvcmVzXG5cdGZpdDogRml0O1xuXHR2YXVsdE9wczogVmF1bHRPcGVyYXRpb25zO1xuXHRmaXRTeW5jOiBGaXRTeW5jXG5cdGF1dG9TeW5jaW5nOiBib29sZWFuXG5cdHN5bmNpbmc6IGJvb2xlYW5cblx0YXV0b1N5bmNJbnRlcnZhbElkOiBudW1iZXIgfCBudWxsXG5cdGZpdFB1bGxSaWJib25JY29uRWw6IEhUTUxFbGVtZW50XG5cdGZpdFB1c2hSaWJib25JY29uRWw6IEhUTUxFbGVtZW50XG5cdGZpdFN5bmNSaWJib25JY29uRWw6IEhUTUxFbGVtZW50XG5cblx0Ly8gaWYgc2V0dGluZ3Mgbm90IGNvbmZpZ3VyZWQsIG9wZW4gc2V0dGluZ3MgdG8gbGV0IHVzZXIgcXVpY2tseSBzZXR1cFxuXHQvLyBOb3RlOiB0aGlzIGlzIG5vdCBhIHN0YWJsZSBmZWF0dXJlIGFuZCBtaWdodCBiZSBkaXNhYmxlZCBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvcGVuUGx1Z2luU2V0dGluZ3MoKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblx0XHRjb25zdCBhcHBXaXRoU2V0dGluZyA9IHRoaXMuYXBwIGFzIGFueSBhcyB7XG5cdFx0XHRzZXR0aW5nOiB7XG5cdFx0XHRcdG9wZW4oKTogdm9pZDtcblx0XHRcdFx0b3BlblRhYkJ5SWQoaWQ6IHN0cmluZyk6IFNldHRpbmdUYWIgfCBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhcHBXaXRoU2V0dGluZy5zZXR0aW5nLm9wZW4oKVxuXHRcdGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlblRhYkJ5SWQoXCJmaXRcIilcblx0fVxuXG5cdGNoZWNrU2V0dGluZ3NDb25maWd1cmVkKCk6IGJvb2xlYW4ge1xuXHRcdGNvbnN0IGFjdGlvbkl0ZW1zOiBBcnJheTxzdHJpbmc+ID0gW11cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5wYXQgPT09IFwiXCIpIHtcblx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goXCJwcm92aWRlIEdpdEh1YiBwZXJzb25hbCBhY2Nlc3MgdG9rZW5cIilcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3Mub3duZXIgPT09IFwiXCIpIHtcblx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goXCJhdXRoZW50aWNhdGUgd2l0aCBwZXJzb25hbCBhY2Nlc3MgdG9rZW5cIilcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MucmVwbyA9PT0gXCJcIikge1xuXHRcdFx0YWN0aW9uSXRlbXMucHVzaChcInNlbGVjdCBhIHJlcG9zaXRvcnkgdG8gc3luYyB0b1wiKVxuXHRcdH1cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5icmFuY2ggPT09IFwiXCIpIHtcblx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goXCJzZWxlY3QgYSBicmFuY2ggdG8gc3luYyB0b1wiKVx0XG5cdFx0fVxuXG5cdFx0aWYgKGFjdGlvbkl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IGluaXRpYWxNZXNzYWdlID0gXCJTZXR0aW5ncyBub3QgY29uZmlndXJlZCwgcGxlYXNlIGNvbXBsZXRlIHRoZSBmb2xsb3dpbmcgYWN0aW9uIGl0ZW1zOlxcblwiICsgYWN0aW9uSXRlbXMuam9pbihcIlxcblwiKVxuXHRcdFx0Y29uc3Qgc2V0dGluZ3NOb3RpY2UgPSBuZXcgRml0Tm90aWNlKHRoaXMuZml0LCBbXCJzdGF0aWNcIl0sIGluaXRpYWxNZXNzYWdlKVxuXHRcdFx0dGhpcy5vcGVuUGx1Z2luU2V0dGluZ3MoKVxuXHRcdFx0c2V0dGluZ3NOb3RpY2UucmVtb3ZlKFwic3RhdGljXCIpXG5cdFx0XHRyZXR1cm4gZmFsc2VcblxuXHRcdH1cblxuXHRcdHRoaXMuZml0LmxvYWRTZXR0aW5ncyh0aGlzLnNldHRpbmdzKVxuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHQvLyB1c2Ugb2YgYXJyb3cgZnVuY3Rpb25zIHRvIGVuc3VyZSB0aGlzIHJlZmVycyB0byB0aGUgRml0UGx1Z2luIGNsYXNzXG5cdHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2sgPSBhc3luYyAobG9jYWxTdG9yZTogUGFydGlhbDxMb2NhbFN0b3Jlcz4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcblx0XHRhd2FpdCB0aGlzLmxvYWRMb2NhbFN0b3JlKClcblx0XHR0aGlzLmxvY2FsU3RvcmUgPSB7Li4udGhpcy5sb2NhbFN0b3JlLCAuLi5sb2NhbFN0b3JlfVxuXHRcdGF3YWl0IHRoaXMuc2F2ZUxvY2FsU3RvcmUoKVxuXHR9XG5cdFxuXHRzeW5jID0gYXN5bmMgKHN5bmNOb3RpY2U6IEZpdE5vdGljZSk6IFByb21pc2U8dm9pZD4gPT4ge1xuXHRcdGlmICghdGhpcy5jaGVja1NldHRpbmdzQ29uZmlndXJlZCgpKSB7IHJldHVybiB9XG5cdFx0YXdhaXQgdGhpcy5sb2FkTG9jYWxTdG9yZSgpXG5cdFx0Y29uc3Qgc3luY1JlY29yZHMgPSBhd2FpdCB0aGlzLmZpdFN5bmMuc3luYyhzeW5jTm90aWNlKVxuXHRcdGlmIChzeW5jUmVjb3Jkcykge1xuXHRcdFx0Y29uc3Qge29wcywgY2xhc2h9ID0gc3luY1JlY29yZHNcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLm5vdGlmeUNvbmZsaWN0cykge1xuXHRcdFx0XHRzaG93VW5hcHBsaWVkQ29uZmxpY3RzKGNsYXNoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3Mubm90aWZ5Q2hhbmdlcykge1xuXHRcdFx0XHRzaG93RmlsZU9wc1JlY29yZChvcHMpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gd3JhcHBlciB0byBjb252ZXJ0IGVycm9yIHRvIG5vdGljZSwgcmV0dXJuIHRydWUgaWYgZXJyb3IgaXMgY2F1Z2h0XG5cdGNhdGNoRXJyb3JBbmROb3RpZnkgPSBhc3luYyA8UCBleHRlbmRzIHVua25vd25bXSwgUj4oZnVuYzogKG5vdGljZTogRml0Tm90aWNlLCAuLi5hcmdzOiBQKSA9PiBQcm9taXNlPFI+LCBub3RpY2U6IEZpdE5vdGljZSwgLi4uYXJnczogUCk6IFByb21pc2U8Unx0cnVlPiA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZ1bmMobm90aWNlLCAuLi5hcmdzKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBPY3Rva2l0SHR0cEVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiZXJyb3Iuc3RhdHVzXCIpXG5cdFx0XHRcdGNvbnNvbGUubG9nKGVycm9yLnN0YXR1cylcblx0XHRcdFx0c3dpdGNoIChlcnJvci5zb3VyY2UpIHtcblx0XHRcdFx0XHRjYXNlICdnZXRUcmVlJzpcblx0XHRcdFx0XHRjYXNlICdnZXRSZWYnOlxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkNhdWdodCBlcnJvciBmcm9tIGdldFJlZjogXCIsIGVycm9yLm1lc3NhZ2UpXG5cdFx0XHRcdFx0XHRpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcblx0XHRcdFx0XHRcdFx0bm90aWNlLnNldE1lc3NhZ2UoXCJGYWlsZWQgdG8gZ2V0IHJlZiwgbWFrZSBzdXJlIHlvdXIgcmVwbyBuYW1lIGFuZCBicmFuY2ggbmFtZSBhcmUgc2V0IGNvcnJlY3RseS5cIiwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5vdGljZS5zZXRNZXNzYWdlKFwiVW5rbm93biBlcnJvciBpbiBnZXR0aW5nIHJlZiwgcmVmZXJzIHRvIGNvbnNvbGUgZm9yIGRldGFpbHMuXCIsIHRydWUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHRcdGNhc2UgJ2dldENvbW1pdFRyZWVTaGEnOlxuXHRcdFx0XHRcdGNhc2UgJ2dldFJlbW90ZVRyZWVTaGEnOlxuXHRcdFx0XHRcdGNhc2UgJ2NyZWF0ZUJsb2InOlxuXHRcdFx0XHRcdGNhc2UgJ2NyZWF0ZVRyZWVOb2RlRnJvbUZpbGUnOlxuXHRcdFx0XHRcdGNhc2UgJ2NyZWF0ZUNvbW1pdCc6XG5cdFx0XHRcdFx0Y2FzZSAndXBkYXRlUmVmJzpcblx0XHRcdFx0XHRjYXNlICdnZXRCbG9iJzpcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5lcnJvcihcIkNhdWdodCB1bmtub3duIGVycm9yOiBcIiwgZXJyb3IpXG5cdFx0XHRub3RpY2Uuc2V0TWVzc2FnZShcIlVuYWJsZSB0byBzeW5jLCBpZiB5b3UgYXJlIG5vdCBjb25uZWN0ZWQgdG8gdGhlIGludGVybmV0LCB0dXJuIG9mZiBhdXRvIHN5bmMuXCIsIHRydWUpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0fVxuXG5cdGxvYWRSaWJib25JY29ucygpIHtcblx0XHQvLyBQdWxsIGZyb20gcmVtb3RlIHRoZW4gUHVzaCB0byByZW1vdGUgaWYgbm8gY2xhc2hpbmcgY2hhbmdlcyBkZXRlY3RlZCBkdXJpbmcgcHVsbFxuXHRcdHRoaXMuZml0U3luY1JpYmJvbkljb25FbCA9IHRoaXMuYWRkUmliYm9uSWNvbignZ2l0aHViJywgJ0ZpdCBTeW5jJywgYXN5bmMgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0aWYgKCB0aGlzLnN5bmNpbmcgfHwgdGhpcy5hdXRvU3luY2luZyApIHsgcmV0dXJuIH1cblx0XHRcdHRoaXMuc3luY2luZyA9IHRydWVcblx0XHRcdHRoaXMuZml0U3luY1JpYmJvbkljb25FbC5hZGRDbGFzcygnYW5pbWF0ZS1pY29uJyk7XG5cdFx0XHRjb25zdCBzeW5jTm90aWNlID0gbmV3IEZpdE5vdGljZSh0aGlzLmZpdCwgW1wibG9hZGluZ1wiXSwgXCJJbml0aWF0aW5nIHN5bmNcIik7XG5cdFx0XHRjb25zdCBlcnJvckNhdWdodCA9IGF3YWl0IHRoaXMuY2F0Y2hFcnJvckFuZE5vdGlmeSh0aGlzLnN5bmMsIHN5bmNOb3RpY2UpO1xuXHRcdFx0dGhpcy5maXRTeW5jUmliYm9uSWNvbkVsLnJlbW92ZUNsYXNzKCdhbmltYXRlLWljb24nKTtcblx0XHRcdGlmIChlcnJvckNhdWdodCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRzeW5jTm90aWNlLnJlbW92ZShcImVycm9yXCIpXG5cdFx0XHRcdHRoaXMuc3luY2luZyA9IGZhbHNlXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0c3luY05vdGljZS5yZW1vdmUoXCJkb25lXCIpXG5cdFx0XHR0aGlzLnN5bmNpbmcgPSBmYWxzZVxuXHRcdH0pO1xuXHRcdHRoaXMuZml0U3luY1JpYmJvbkljb25FbC5hZGRDbGFzcygnZml0LXN5bmMtcmliYm9uLWVsJyk7XG5cdH1cblxuXHRhc3luYyBhdXRvU3luYygpIHtcblx0XHRpZiAoIHRoaXMuc3luY2luZyB8fCB0aGlzLmF1dG9TeW5jaW5nICkgeyByZXR1cm4gfVxuXHRcdHRoaXMuYXV0b1N5bmNpbmcgPSB0cnVlXG5cdFx0Y29uc3Qgc3luY05vdGljZSA9IG5ldyBGaXROb3RpY2UoXG5cdFx0XHR0aGlzLmZpdCwgXG5cdFx0XHRbXCJsb2FkaW5nXCJdLCBcblx0XHRcdFwiQXV0byBzeW5jaW5nXCIsIFxuXHRcdFx0MCwgXG5cdFx0XHR0aGlzLnNldHRpbmdzLmF1dG9TeW5jID09PSBcIm11dGVkXCJcblx0XHQpO1xuXHRcdGNvbnN0IGVycm9yQ2F1Z2h0ID0gYXdhaXQgdGhpcy5jYXRjaEVycm9yQW5kTm90aWZ5KHRoaXMuc3luYywgc3luY05vdGljZSk7XG5cdFx0aWYgKGVycm9yQ2F1Z2h0ID09PSB0cnVlKSB7XG5cdFx0XHRzeW5jTm90aWNlLnJlbW92ZShcImVycm9yXCIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHN5bmNOb3RpY2UucmVtb3ZlKClcblx0XHR9XG5cdFx0dGhpcy5hdXRvU3luY2luZyA9IGZhbHNlXG5cdH1cblxuXHRhc3luYyBhdXRvVXBkYXRlKCkge1xuXHRcdGlmICghKHRoaXMuc2V0dGluZ3MuYXV0b1N5bmMgPT09IFwib2ZmXCIpICYmICF0aGlzLnN5bmNpbmcgJiYgIXRoaXMuYXV0b1N5bmNpbmcgJiYgdGhpcy5jaGVja1NldHRpbmdzQ29uZmlndXJlZCgpKSB7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvU3luYyA9PT0gXCJvblwiIHx8IHRoaXMuc2V0dGluZ3MuYXV0b1N5bmMgPT09IFwibXV0ZWRcIikge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmF1dG9TeW5jKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b1N5bmMgPT09IFwicmVtaW5kXCIpIHtcblx0XHRcdFx0Y29uc3QgeyB1cGRhdGVkIH0gPSBhd2FpdCB0aGlzLmZpdC5yZW1vdGVVcGRhdGVkKCk7XG5cdFx0XHRcdGlmICh1cGRhdGVkKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5pdGlhbE1lc3NhZ2UgPSBcIlJlbW90ZSB1cGRhdGUgZGV0ZWN0ZWQsIHBsZWFzZSBwdWxsIHRoZSBsYXRlc3QgY2hhbmdlcy5cIjtcblx0XHRcdFx0XHRjb25zdCBpbnRlcnZhbE5vdGljZSA9IG5ldyBGaXROb3RpY2UodGhpcy5maXQsIFtcInN0YXRpY1wiXSwgaW5pdGlhbE1lc3NhZ2UpO1xuXHRcdFx0XHRcdGludGVydmFsTm90aWNlLnJlbW92ZShcInN0YXRpY1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblxuXHRhc3luYyBzdGFydE9yVXBkYXRlQXV0b1N5bmNJbnRlcnZhbCgpIHtcbiAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgaW50ZXJ2YWwgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5hdXRvU3luY0ludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5hdXRvU3luY0ludGVydmFsSWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgcmVtb3RlIGV2ZXJ5IFggbWludXRlcyAoc2V0IGluIHNldHRpbmdzKVxuICAgICAgICB0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG5cdFx0XHRhd2FpdCB0aGlzLmF1dG9VcGRhdGUoKTtcbiAgICAgICAgfSwgdGhpcy5zZXR0aW5ncy5jaGVja0V2ZXJ5WE1pbnV0ZXMgKiA2MCAqIDEwMDApO1xuICAgIH1cblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblx0XHRhd2FpdCB0aGlzLmxvYWRMb2NhbFN0b3JlKCk7XG5cdFx0dGhpcy52YXVsdE9wcyA9IG5ldyBWYXVsdE9wZXJhdGlvbnModGhpcy5hcHAudmF1bHQpXG5cdFx0dGhpcy5maXQgPSBuZXcgRml0KHRoaXMuc2V0dGluZ3MsIHRoaXMubG9jYWxTdG9yZSwgdGhpcy52YXVsdE9wcylcblx0XHR0aGlzLmZpdFN5bmMgPSBuZXcgRml0U3luYyh0aGlzLmZpdCwgdGhpcy52YXVsdE9wcywgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKVxuXHRcdHRoaXMuc3luY2luZyA9IGZhbHNlXG5cdFx0dGhpcy5hdXRvU3luY2luZyA9IGZhbHNlXG5cdFx0dGhpcy5zZXR0aW5nVGFiID0gbmV3IEZpdFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpXG5cdFx0dGhpcy5sb2FkUmliYm9uSWNvbnMoKTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBGaXRTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cdFx0XG5cdFx0Ly8gcmVnaXN0ZXIgaW50ZXJ2YWwgdG8gcmVwZWF0IGF1dG8gY2hlY2tcblx0XHRhd2FpdCB0aGlzLnN0YXJ0T3JVcGRhdGVBdXRvU3luY0ludGVydmFsKCk7XG5cdH1cblxuXHRvbnVubG9hZCgpIHtcblx0XHRpZiAodGhpcy5hdXRvU3luY0ludGVydmFsSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgfVxuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdGNvbnN0IHVzZXJTZXR0aW5nID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpXG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCB1c2VyU2V0dGluZyk7XG5cdFx0Y29uc3Qgc2V0dGluZ3NPYmo6IEZpdFNldHRpbmdzID0gT2JqZWN0LmtleXMoREVGQVVMVF9TRVRUSU5HUykucmVkdWNlKFxuXHRcdFx0KG9iaiwga2V5OiBrZXlvZiBGaXRTZXR0aW5ncykgPT4ge1xuXHRcdFx0XHRpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdGlmIChrZXkgPT0gXCJjaGVja0V2ZXJ5WE1pbnV0ZXNcIikge1xuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBOdW1iZXIoc2V0dGluZ3Nba2V5XSk7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0XHRlbHNlIGlmIChrZXkgPT09IFwibm90aWZ5Q2hhbmdlc1wiIHx8IGtleSA9PT0gXCJub3RpZnlDb25mbGljdHNcIikge1xuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBCb29sZWFuKHNldHRpbmdzW2tleV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdG9ialtrZXldID0gc2V0dGluZ3Nba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sIHt9IGFzIEZpdFNldHRpbmdzKTtcblx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3NPYmpcblx0fVxuXG5cdGFzeW5jIGxvYWRMb2NhbFN0b3JlKCkge1xuXHRcdGNvbnN0IGxvY2FsU3RvcmUgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0xPQ0FMX1NUT1JFLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHRcdGNvbnN0IGxvY2FsU3RvcmVPYmo6IExvY2FsU3RvcmVzID0gT2JqZWN0LmtleXMoREVGQVVMVF9MT0NBTF9TVE9SRSkucmVkdWNlKFxuXHRcdFx0KG9iaiwga2V5OiBrZXlvZiBMb2NhbFN0b3JlcykgPT4ge1xuXHRcdFx0XHRpZiAobG9jYWxTdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0b2JqW2tleV0gPSBsb2NhbFN0b3JlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sIHt9IGFzIExvY2FsU3RvcmVzKTtcblx0XHR0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlT2JqXG5cdH1cblxuXHQvLyBhbGxvdyBzYXZpbmcgb2YgbG9jYWwgc3RvcmVzIHByb3BlcnR5LCBwYXNzZWQgaW4gcHJvcGVydGllcyB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHN0b3JlZCB2YWx1ZVxuXHRhc3luYyBzYXZlTG9jYWxTdG9yZSgpIHtcblx0XHRjb25zdCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9MT0NBTF9TVE9SRSwgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHsuLi5kYXRhLCAuLi50aGlzLmxvY2FsU3RvcmV9KVxuXHRcdC8vIHN5bmMgbG9jYWwgc3RvcmUgdG8gRml0IGNsYXNzIGFzIHdlbGwgdXBvbiBzYXZpbmdcblx0XHR0aGlzLmZpdC5sb2FkTG9jYWxTdG9yZSh0aGlzLmxvY2FsU3RvcmUpXG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0Y29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh7Li4uZGF0YSwgLi4udGhpcy5zZXR0aW5nc30pO1xuXHRcdC8vIHVwZGF0ZSBhdXRvIHN5bmMgaW50ZXJ2YWwgd2l0aCBuZXcgc2V0dGluZ1xuXHRcdHRoaXMuc3RhcnRPclVwZGF0ZUF1dG9TeW5jSW50ZXJ2YWwoKTtcblx0XHQvLyBzeW5jIHNldHRpbmdzIHRvIEZpdCBjbGFzcyBhcyB3ZWxsIHVwb24gc2F2aW5nXG5cdFx0dGhpcy5maXQubG9hZFNldHRpbmdzKHRoaXMuc2V0dGluZ3MpXG5cdH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIoc3RhdGUsIG5hbWUsIG1ldGhvZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGZvciBiZWZvcmUgaG9vayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIHJldHVybiBuYW1lLnJldmVyc2UoKS5yZWR1Y2UoKGNhbGxiYWNrLCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXIuYmluZChudWxsLCBzdGF0ZSwgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sIG1ldGhvZCkoKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5yZWR1Y2UoKG1ldGhvZCwgcmVnaXN0ZXJlZCkgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQuaG9vay5iaW5kKG51bGwsIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgfSwgbWV0aG9kKSgpO1xuICB9KTtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhvb2soc3RhdGUsIGtpbmQsIG5hbWUsIGhvb2spIHtcbiAgY29uc3Qgb3JpZyA9IGhvb2s7XG4gIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICBzdGF0ZS5yZWdpc3RyeVtuYW1lXSA9IFtdO1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiYmVmb3JlXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG9yaWcuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJhZnRlclwiKSB7XG4gICAgaG9vayA9IChtZXRob2QsIG9wdGlvbnMpID0+IHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKChyZXN1bHRfKSA9PiB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0XztcbiAgICAgICAgICByZXR1cm4gb3JpZyhyZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImVycm9yXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9yaWcoZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGUucmVnaXN0cnlbbmFtZV0ucHVzaCh7XG4gICAgaG9vazogaG9vayxcbiAgICBvcmlnOiBvcmlnLFxuICB9KTtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUhvb2soc3RhdGUsIG5hbWUsIG1ldGhvZCkge1xuICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaW5kZXggPSBzdGF0ZS5yZWdpc3RyeVtuYW1lXVxuICAgIC5tYXAoKHJlZ2lzdGVyZWQpID0+IHtcbiAgICAgIHJldHVybiByZWdpc3RlcmVkLm9yaWc7XG4gICAgfSlcbiAgICAuaW5kZXhPZihtZXRob2QpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgeyByZWdpc3RlciB9IGZyb20gXCIuL2xpYi9yZWdpc3Rlci5qc1wiO1xuaW1wb3J0IHsgYWRkSG9vayB9IGZyb20gXCIuL2xpYi9hZGQuanNcIjtcbmltcG9ydCB7IHJlbW92ZUhvb2sgfSBmcm9tIFwiLi9saWIvcmVtb3ZlLmpzXCI7XG5cbi8vIGJpbmQgd2l0aCBhcnJheSBvZiBhcmd1bWVudHM6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTc5MjkxM1xuY29uc3QgYmluZCA9IEZ1bmN0aW9uLmJpbmQ7XG5jb25zdCBiaW5kYWJsZSA9IGJpbmQuYmluZChiaW5kKTtcblxuZnVuY3Rpb24gYmluZEFwaShob29rLCBzdGF0ZSwgbmFtZSkge1xuICBjb25zdCByZW1vdmVIb29rUmVmID0gYmluZGFibGUocmVtb3ZlSG9vaywgbnVsbCkuYXBwbHkoXG4gICAgbnVsbCxcbiAgICBuYW1lID8gW3N0YXRlLCBuYW1lXSA6IFtzdGF0ZV1cbiAgKTtcbiAgaG9vay5hcGkgPSB7IHJlbW92ZTogcmVtb3ZlSG9va1JlZiB9O1xuICBob29rLnJlbW92ZSA9IHJlbW92ZUhvb2tSZWY7XG4gIFtcImJlZm9yZVwiLCBcImVycm9yXCIsIFwiYWZ0ZXJcIiwgXCJ3cmFwXCJdLmZvckVhY2goKGtpbmQpID0+IHtcbiAgICBjb25zdCBhcmdzID0gbmFtZSA/IFtzdGF0ZSwga2luZCwgbmFtZV0gOiBbc3RhdGUsIGtpbmRdO1xuICAgIGhvb2tba2luZF0gPSBob29rLmFwaVtraW5kXSA9IGJpbmRhYmxlKGFkZEhvb2ssIG51bGwpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gU2luZ3VsYXIoKSB7XG4gIGNvbnN0IHNpbmd1bGFySG9va05hbWUgPSBTeW1ib2woXCJTaW5ndWxhclwiKTtcbiAgY29uc3Qgc2luZ3VsYXJIb29rU3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuICBjb25zdCBzaW5ndWxhckhvb2sgPSByZWdpc3Rlci5iaW5kKG51bGwsIHNpbmd1bGFySG9va1N0YXRlLCBzaW5ndWxhckhvb2tOYW1lKTtcbiAgYmluZEFwaShzaW5ndWxhckhvb2ssIHNpbmd1bGFySG9va1N0YXRlLCBzaW5ndWxhckhvb2tOYW1lKTtcbiAgcmV0dXJuIHNpbmd1bGFySG9vaztcbn1cblxuZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuXG4gIGNvbnN0IGhvb2sgPSByZWdpc3Rlci5iaW5kKG51bGwsIHN0YXRlKTtcbiAgYmluZEFwaShob29rLCBzdGF0ZSk7XG5cbiAgcmV0dXJuIGhvb2s7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgU2luZ3VsYXIsIENvbGxlY3Rpb24gfTtcbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgIi8vIHBrZy9kaXN0LXNyYy9kZWZhdWx0cy5qc1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSBcInVuaXZlcnNhbC11c2VyLWFnZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTiA9IFwiMC4wLjAtZGV2ZWxvcG1lbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2RlZmF1bHRzLmpzXG52YXIgdXNlckFnZW50ID0gYG9jdG9raXQtZW5kcG9pbnQuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWA7XG52YXIgREVGQVVMVFMgPSB7XG4gIG1ldGhvZDogXCJHRVRcIixcbiAgYmFzZVVybDogXCJodHRwczovL2FwaS5naXRodWIuY29tXCIsXG4gIGhlYWRlcnM6IHtcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uXCIsXG4gICAgXCJ1c2VyLWFnZW50XCI6IHVzZXJBZ2VudFxuICB9LFxuICBtZWRpYVR5cGU6IHtcbiAgICBmb3JtYXQ6IFwiXCJcbiAgfVxufTtcblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvbG93ZXJjYXNlLWtleXMuanNcbmZ1bmN0aW9uIGxvd2VyY2FzZUtleXMob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZSgobmV3T2JqLCBrZXkpID0+IHtcbiAgICBuZXdPYmpba2V5LnRvTG93ZXJDYXNlKCldID0gb2JqZWN0W2tleV07XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSwge30pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9pcy1wbGFpbi1vYmplY3QuanNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKEN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL21lcmdlLWRlZXAuanNcbmZ1bmN0aW9uIG1lcmdlRGVlcChkZWZhdWx0cywgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbnNba2V5XSkpIHtcbiAgICAgIGlmICghKGtleSBpbiBkZWZhdWx0cykpXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VEZWVwKGRlZmF1bHRzW2tleV0sIG9wdGlvbnNba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvcmVtb3ZlLXVuZGVmaW5lZC1wcm9wZXJ0aWVzLmpzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvbWVyZ2UuanNcbmZ1bmN0aW9uIG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHJvdXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbGV0IFttZXRob2QsIHVybF0gPSByb3V0ZS5zcGxpdChcIiBcIik7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odXJsID8geyBtZXRob2QsIHVybCB9IDogeyB1cmw6IG1ldGhvZCB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGUpO1xuICB9XG4gIG9wdGlvbnMuaGVhZGVycyA9IGxvd2VyY2FzZUtleXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zKTtcbiAgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zLmhlYWRlcnMpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gbWVyZ2VEZWVwKGRlZmF1bHRzIHx8IHt9LCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMudXJsID09PSBcIi9ncmFwaHFsXCIpIHtcbiAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzPy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzID0gZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzLmZpbHRlcihcbiAgICAgICAgKHByZXZpZXcpID0+ICFtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cy5pbmNsdWRlcyhwcmV2aWV3KVxuICAgICAgKS5jb25jYXQobWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpO1xuICAgIH1cbiAgICBtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyA9IChtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyB8fCBbXSkubWFwKChwcmV2aWV3KSA9PiBwcmV2aWV3LnJlcGxhY2UoLy1wcmV2aWV3LywgXCJcIikpO1xuICB9XG4gIHJldHVybiBtZXJnZWRPcHRpb25zO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9hZGQtcXVlcnktcGFyYW1ldGVycy5qc1xuZnVuY3Rpb24gYWRkUXVlcnlQYXJhbWV0ZXJzKHVybCwgcGFyYW1ldGVycykge1xuICBjb25zdCBzZXBhcmF0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICByZXR1cm4gdXJsICsgc2VwYXJhdG9yICsgbmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgaWYgKG5hbWUgPT09IFwicVwiKSB7XG4gICAgICByZXR1cm4gXCJxPVwiICsgcGFyYW1ldGVycy5xLnNwbGl0KFwiK1wiKS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiK1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke25hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtZXRlcnNbbmFtZV0pfWA7XG4gIH0pLmpvaW4oXCImXCIpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9leHRyYWN0LXVybC12YXJpYWJsZS1uYW1lcy5qc1xudmFyIHVybFZhcmlhYmxlUmVnZXggPSAvXFx7W159XStcXH0vZztcbmZ1bmN0aW9uIHJlbW92ZU5vbkNoYXJzKHZhcmlhYmxlTmFtZSkge1xuICByZXR1cm4gdmFyaWFibGVOYW1lLnJlcGxhY2UoL15cXFcrfFxcVyskL2csIFwiXCIpLnNwbGl0KC8sLyk7XG59XG5mdW5jdGlvbiBleHRyYWN0VXJsVmFyaWFibGVOYW1lcyh1cmwpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHVybC5tYXRjaCh1cmxWYXJpYWJsZVJlZ2V4KTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLm1hcChyZW1vdmVOb25DaGFycykucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9vbWl0LmpzXG5mdW5jdGlvbiBvbWl0KG9iamVjdCwga2V5c1RvT21pdCkge1xuICBjb25zdCByZXN1bHQgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgaWYgKGtleXNUb09taXQuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvdXJsLXRlbXBsYXRlLmpzXG5mdW5jdGlvbiBlbmNvZGVSZXNlcnZlZChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvKCVbMC05QS1GYS1mXXsyfSkvZykubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBpZiAoIS8lWzAtOUEtRmEtZl0vLnRlc3QocGFydCkpIHtcbiAgICAgIHBhcnQgPSBlbmNvZGVVUkkocGFydCkucmVwbGFjZSgvJTVCL2csIFwiW1wiKS5yZXBsYWNlKC8lNUQvZywgXCJdXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydDtcbiAgfSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCIlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcbiAgdmFsdWUgPSBvcGVyYXRvciA9PT0gXCIrXCIgfHwgb3BlcmF0b3IgPT09IFwiI1wiID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVW5yZXNlcnZlZCh2YWx1ZSk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIgKyB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgcmV0dXJuIG9wZXJhdG9yID09PSBcIjtcIiB8fCBvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHRba2V5XSwgcmVzdWx0ID0gW107XG4gIGlmIChpc0RlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBcIlwiKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgaWYgKG1vZGlmaWVyICYmIG1vZGlmaWVyICE9PSBcIipcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogXCJcIilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUyLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWVba10pKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXSwgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0bXAgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTIpIHtcbiAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZTIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVbnJlc2VydmVkKGspKTtcbiAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNLZXlPcGVyYXRvcihvcGVyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVbnJlc2VydmVkKGtleSkgKyBcIj1cIiArIHRtcC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wZXJhdG9yID09PSBcIjtcIikge1xuICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlwiICYmIChvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiKSkge1xuICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFwiXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VVcmwodGVtcGxhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBhbmQ6IGV4cGFuZC5iaW5kKG51bGwsIHRlbXBsYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gZXhwYW5kKHRlbXBsYXRlLCBjb250ZXh0KSB7XG4gIHZhciBvcGVyYXRvcnMgPSBbXCIrXCIsIFwiI1wiLCBcIi5cIiwgXCIvXCIsIFwiO1wiLCBcIj9cIiwgXCImXCJdO1xuICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoXG4gICAgL1xceyhbXlxce1xcfV0rKVxcfXwoW15cXHtcXH1dKykvZyxcbiAgICBmdW5jdGlvbihfLCBleHByZXNzaW9uLCBsaXRlcmFsKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICBsZXQgb3BlcmF0b3IgPSBcIlwiO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGV4cHJlc3Npb24uY2hhckF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uLnNwbGl0KC8sL2cpLmZvckVhY2goZnVuY3Rpb24odmFyaWFibGUpIHtcbiAgICAgICAgICB2YXIgdG1wID0gLyhbXjpcXCpdKikoPzo6KFxcZCspfChcXCopKT8vLmV4ZWModmFyaWFibGUpO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwgdG1wWzFdLCB0bXBbMl0gfHwgdG1wWzNdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3BlcmF0b3IgJiYgb3BlcmF0b3IgIT09IFwiK1wiKSB7XG4gICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFwiO1xuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFwiJlwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09IFwiI1wiKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiBcIlwiKSArIHZhbHVlcy5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKHRlbXBsYXRlID09PSBcIi9cIikge1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9wYXJzZS5qc1xuZnVuY3Rpb24gcGFyc2Uob3B0aW9ucykge1xuICBsZXQgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgbGV0IHVybCA9IChvcHRpb25zLnVybCB8fCBcIi9cIikucmVwbGFjZSgvOihbYS16XVxcdyspL2csIFwieyQxfVwiKTtcbiAgbGV0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMpO1xuICBsZXQgYm9keTtcbiAgbGV0IHBhcmFtZXRlcnMgPSBvbWl0KG9wdGlvbnMsIFtcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwiYmFzZVVybFwiLFxuICAgIFwidXJsXCIsXG4gICAgXCJoZWFkZXJzXCIsXG4gICAgXCJyZXF1ZXN0XCIsXG4gICAgXCJtZWRpYVR5cGVcIlxuICBdKTtcbiAgY29uc3QgdXJsVmFyaWFibGVOYW1lcyA9IGV4dHJhY3RVcmxWYXJpYWJsZU5hbWVzKHVybCk7XG4gIHVybCA9IHBhcnNlVXJsKHVybCkuZXhwYW5kKHBhcmFtZXRlcnMpO1xuICBpZiAoIS9eaHR0cC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gb3B0aW9ucy5iYXNlVXJsICsgdXJsO1xuICB9XG4gIGNvbnN0IG9taXR0ZWRQYXJhbWV0ZXJzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChvcHRpb24pID0+IHVybFZhcmlhYmxlTmFtZXMuaW5jbHVkZXMob3B0aW9uKSkuY29uY2F0KFwiYmFzZVVybFwiKTtcbiAgY29uc3QgcmVtYWluaW5nUGFyYW1ldGVycyA9IG9taXQocGFyYW1ldGVycywgb21pdHRlZFBhcmFtZXRlcnMpO1xuICBjb25zdCBpc0JpbmFyeVJlcXVlc3QgPSAvYXBwbGljYXRpb25cXC9vY3RldC1zdHJlYW0vaS50ZXN0KGhlYWRlcnMuYWNjZXB0KTtcbiAgaWYgKCFpc0JpbmFyeVJlcXVlc3QpIHtcbiAgICBpZiAob3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0KSB7XG4gICAgICBoZWFkZXJzLmFjY2VwdCA9IGhlYWRlcnMuYWNjZXB0LnNwbGl0KC8sLykubWFwKFxuICAgICAgICAoZm9ybWF0KSA9PiBmb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAvYXBwbGljYXRpb25cXC92bmQoXFwuXFx3KykoXFwudjMpPyhcXC5cXHcrKT8oXFwranNvbik/JC8sXG4gICAgICAgICAgYGFwcGxpY2F0aW9uL3ZuZCQxJDIuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YFxuICAgICAgICApXG4gICAgICApLmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICBpZiAodXJsLmVuZHNXaXRoKFwiL2dyYXBocWxcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlciA9IGhlYWRlcnMuYWNjZXB0Lm1hdGNoKC9bXFx3LV0rKD89LXByZXZpZXcpL2cpIHx8IFtdO1xuICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlci5jb25jYXQob3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpLm1hcCgocHJldmlldykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMubWVkaWFUeXBlLmZvcm1hdCA/IGAuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YCA6IFwiK2pzb25cIjtcbiAgICAgICAgICByZXR1cm4gYGFwcGxpY2F0aW9uL3ZuZC5naXRodWIuJHtwcmV2aWV3fS1wcmV2aWV3JHtmb3JtYXR9YDtcbiAgICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChbXCJHRVRcIiwgXCJIRUFEXCJdLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICB1cmwgPSBhZGRRdWVyeVBhcmFtZXRlcnModXJsLCByZW1haW5pbmdQYXJhbWV0ZXJzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXCJkYXRhXCIgaW4gcmVtYWluaW5nUGFyYW1ldGVycykge1xuICAgICAgYm9keSA9IHJlbWFpbmluZ1BhcmFtZXRlcnMuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHJlbWFpbmluZ1BhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgICAgICBib2R5ID0gcmVtYWluaW5nUGFyYW1ldGVycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFoZWFkZXJzW1wiY29udGVudC10eXBlXCJdICYmIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiO1xuICB9XG4gIGlmIChbXCJQQVRDSFwiLCBcIlBVVFwiXS5pbmNsdWRlcyhtZXRob2QpICYmIHR5cGVvZiBib2R5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYm9keSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgeyBtZXRob2QsIHVybCwgaGVhZGVycyB9LFxuICAgIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiID8geyBib2R5IH0gOiBudWxsLFxuICAgIG9wdGlvbnMucmVxdWVzdCA/IHsgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0IH0gOiBudWxsXG4gICk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9lbmRwb2ludC13aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiBlbmRwb2ludFdpdGhEZWZhdWx0cyhkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBhcnNlKG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZERlZmF1bHRzLCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBERUZBVUxUUzIgPSBtZXJnZShvbGREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICBjb25zdCBlbmRwb2ludDIgPSBlbmRwb2ludFdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGVuZHBvaW50Miwge1xuICAgIERFRkFVTFRTOiBERUZBVUxUUzIsXG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMiksXG4gICAgbWVyZ2U6IG1lcmdlLmJpbmQobnVsbCwgREVGQVVMVFMyKSxcbiAgICBwYXJzZVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgZW5kcG9pbnQgPSB3aXRoRGVmYXVsdHMobnVsbCwgREVGQVVMVFMpO1xuZXhwb3J0IHtcbiAgZW5kcG9pbnRcbn07XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIgJiYgXCJ1c2VyQWdlbnRcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbi5zdWJzdHIoMSl9ICgke3Byb2Nlc3MucGxhdGZvcm19OyAke1xuICAgICAgcHJvY2Vzcy5hcmNoXG4gICAgfSlgO1xuICB9XG5cbiAgcmV0dXJuIFwiPGVudmlyb25tZW50IHVuZGV0ZWN0YWJsZT5cIjtcbn1cbiIsICJjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIC8qKlxuICAgKiBodHRwIHN0YXR1cyBjb2RlXG4gICAqL1xuICBzdGF0dXM7XG4gIC8qKlxuICAgKiBSZXF1ZXN0IG9wdGlvbnMgdGhhdCBsZWFkIHRvIHRoZSBlcnJvci5cbiAgICovXG4gIHJlcXVlc3Q7XG4gIC8qKlxuICAgKiBSZXNwb25zZSBvYmplY3QgaWYgYSByZXNwb25zZSB3YXMgcmVjZWl2ZWRcbiAgICovXG4gIHJlc3BvbnNlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gXCJIdHRwRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgaWYgKFwicmVzcG9uc2VcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QpO1xuICAgIGlmIChvcHRpb25zLnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICByZXF1ZXN0Q29weS5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMsIHtcbiAgICAgICAgYXV0aG9yaXphdGlvbjogb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbi5yZXBsYWNlKFxuICAgICAgICAgIC8gLiokLyxcbiAgICAgICAgICBcIiBbUkVEQUNURURdXCJcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3RDb3B5LnVybCA9IHJlcXVlc3RDb3B5LnVybC5yZXBsYWNlKC9cXGJjbGllbnRfc2VjcmV0PVxcdysvZywgXCJjbGllbnRfc2VjcmV0PVtSRURBQ1RFRF1cIikucmVwbGFjZSgvXFxiYWNjZXNzX3Rva2VuPVxcdysvZywgXCJhY2Nlc3NfdG9rZW49W1JFREFDVEVEXVwiKTtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0Q29weTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUmVxdWVzdEVycm9yXG59O1xuIiwgIi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xuaW1wb3J0IHsgZW5kcG9pbnQgfSBmcm9tIFwiQG9jdG9raXQvZW5kcG9pbnRcIjtcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9pcy1wbGFpbi1vYmplY3QuanNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKEN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9mZXRjaC13cmFwcGVyLmpzXG5pbXBvcnQgeyBSZXF1ZXN0RXJyb3IgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdC1lcnJvclwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvZ2V0LWJ1ZmZlci1yZXNwb25zZS5qc1xuZnVuY3Rpb24gZ2V0QnVmZmVyUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9mZXRjaC13cmFwcGVyLmpzXG5mdW5jdGlvbiBmZXRjaFdyYXBwZXIocmVxdWVzdE9wdGlvbnMpIHtcbiAgY29uc3QgbG9nID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdCAmJiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmxvZyA/IHJlcXVlc3RPcHRpb25zLnJlcXVlc3QubG9nIDogY29uc29sZTtcbiAgY29uc3QgcGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8ucGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ICE9PSBmYWxzZTtcbiAgaWYgKGlzUGxhaW5PYmplY3QocmVxdWVzdE9wdGlvbnMuYm9keSkgfHwgQXJyYXkuaXNBcnJheShyZXF1ZXN0T3B0aW9ucy5ib2R5KSkge1xuICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0T3B0aW9ucy5ib2R5KTtcbiAgfVxuICBsZXQgaGVhZGVycyA9IHt9O1xuICBsZXQgc3RhdHVzO1xuICBsZXQgdXJsO1xuICBsZXQgeyBmZXRjaCB9ID0gZ2xvYmFsVGhpcztcbiAgaWYgKHJlcXVlc3RPcHRpb25zLnJlcXVlc3Q/LmZldGNoKSB7XG4gICAgZmV0Y2ggPSByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmZldGNoO1xuICB9XG4gIGlmICghZmV0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImZldGNoIGlzIG5vdCBzZXQuIFBsZWFzZSBwYXNzIGEgZmV0Y2ggaW1wbGVtZW50YXRpb24gYXMgbmV3IE9jdG9raXQoeyByZXF1ZXN0OiB7IGZldGNoIH19KS4gTGVhcm4gbW9yZSBhdCBodHRwczovL2dpdGh1Yi5jb20vb2N0b2tpdC9vY3Rva2l0LmpzLyNmZXRjaC1taXNzaW5nXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBmZXRjaChyZXF1ZXN0T3B0aW9ucy51cmwsIHtcbiAgICBtZXRob2Q6IHJlcXVlc3RPcHRpb25zLm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0T3B0aW9ucy5ib2R5LFxuICAgIC8vIEhlYWRlciB2YWx1ZXMgbXVzdCBiZSBgc3RyaW5nYFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RPcHRpb25zLmhlYWRlcnMpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW1xuICAgICAgICBuYW1lLFxuICAgICAgICBTdHJpbmcodmFsdWUpXG4gICAgICBdKVxuICAgICksXG4gICAgc2lnbmFsOiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0Py5zaWduYWwsXG4gICAgLy8gZHVwbGV4IG11c3QgYmUgc2V0IGlmIHJlcXVlc3QuYm9keSBpcyBSZWFkYWJsZVN0cmVhbSBvciBBc3luYyBJdGVyYWJsZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdGluaXQtZHVwbGV4LlxuICAgIC4uLnJlcXVlc3RPcHRpb25zLmJvZHkgJiYgeyBkdXBsZXg6IFwiaGFsZlwiIH1cbiAgfSkudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICB1cmwgPSByZXNwb25zZS51cmw7XG4gICAgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGZvciAoY29uc3Qga2V5QW5kVmFsdWUgb2YgcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgaGVhZGVyc1trZXlBbmRWYWx1ZVswXV0gPSBrZXlBbmRWYWx1ZVsxXTtcbiAgICB9XG4gICAgaWYgKFwiZGVwcmVjYXRpb25cIiBpbiBoZWFkZXJzKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gaGVhZGVycy5saW5rICYmIGhlYWRlcnMubGluay5tYXRjaCgvPChbXj5dKyk+OyByZWw9XCJkZXByZWNhdGlvblwiLyk7XG4gICAgICBjb25zdCBkZXByZWNhdGlvbkxpbmsgPSBtYXRjaGVzICYmIG1hdGNoZXMucG9wKCk7XG4gICAgICBsb2cud2FybihcbiAgICAgICAgYFtAb2N0b2tpdC9yZXF1ZXN0XSBcIiR7cmVxdWVzdE9wdGlvbnMubWV0aG9kfSAke3JlcXVlc3RPcHRpb25zLnVybH1cIiBpcyBkZXByZWNhdGVkLiBJdCBpcyBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBvbiAke2hlYWRlcnMuc3Vuc2V0fSR7ZGVwcmVjYXRpb25MaW5rID8gYC4gU2VlICR7ZGVwcmVjYXRpb25MaW5rfWAgOiBcIlwifWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzdGF0dXMgPT09IDIwNSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdE9wdGlvbnMubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgaWYgKHN0YXR1cyA8IDQwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHN0YXR1cywge1xuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IoXCJOb3QgbW9kaWZpZWRcIiwgc3RhdHVzLCB7XG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGE6IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID49IDQwMCkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IodG9FcnJvck1lc3NhZ2UoZGF0YSksIHN0YXR1cywge1xuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ID8gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKSA6IHJlc3BvbnNlLmJvZHk7XG4gIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGRhdGFcbiAgICB9O1xuICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIilcbiAgICAgIHRocm93IGVycm9yO1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiAmJiBcImNhdXNlXCIgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZS5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IuY2F1c2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmNhdXNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKG1lc3NhZ2UsIDUwMCwge1xuICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICB9KTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgaWYgKC9hcHBsaWNhdGlvblxcL2pzb24vLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiByZXNwb25zZS50ZXh0KCkpLmNhdGNoKCgpID0+IFwiXCIpO1xuICB9XG4gIGlmICghY29udGVudFR5cGUgfHwgL150ZXh0XFwvfGNoYXJzZXQ9dXRmLTgkLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIGdldEJ1ZmZlclJlc3BvbnNlKHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIHRvRXJyb3JNZXNzYWdlKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBkYXRhO1xuICBsZXQgc3VmZml4O1xuICBpZiAoXCJkb2N1bWVudGF0aW9uX3VybFwiIGluIGRhdGEpIHtcbiAgICBzdWZmaXggPSBgIC0gJHtkYXRhLmRvY3VtZW50YXRpb25fdXJsfWA7XG4gIH0gZWxzZSB7XG4gICAgc3VmZml4ID0gXCJcIjtcbiAgfVxuICBpZiAoXCJtZXNzYWdlXCIgaW4gZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuZXJyb3JzKSkge1xuICAgICAgcmV0dXJuIGAke2RhdGEubWVzc2FnZX06ICR7ZGF0YS5lcnJvcnMubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKFwiLCBcIil9JHtzdWZmaXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2RhdGEubWVzc2FnZX0ke3N1ZmZpeH1gO1xuICB9XG4gIHJldHVybiBgVW5rbm93biBlcnJvcjogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZEVuZHBvaW50LCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBlbmRwb2ludDIgPSBvbGRFbmRwb2ludC5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IG5ld0FwaSA9IGZ1bmN0aW9uKHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgZW5kcG9pbnRPcHRpb25zID0gZW5kcG9pbnQyLm1lcmdlKHJvdXRlLCBwYXJhbWV0ZXJzKTtcbiAgICBpZiAoIWVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0IHx8ICFlbmRwb2ludE9wdGlvbnMucmVxdWVzdC5ob29rKSB7XG4gICAgICByZXR1cm4gZmV0Y2hXcmFwcGVyKGVuZHBvaW50Mi5wYXJzZShlbmRwb2ludE9wdGlvbnMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdDIgPSAocm91dGUyLCBwYXJhbWV0ZXJzMikgPT4ge1xuICAgICAgcmV0dXJuIGZldGNoV3JhcHBlcihcbiAgICAgICAgZW5kcG9pbnQyLnBhcnNlKGVuZHBvaW50Mi5tZXJnZShyb3V0ZTIsIHBhcmFtZXRlcnMyKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHJlcXVlc3QyLCB7XG4gICAgICBlbmRwb2ludDogZW5kcG9pbnQyLFxuICAgICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIGVuZHBvaW50MilcbiAgICB9KTtcbiAgICByZXR1cm4gZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QuaG9vayhyZXF1ZXN0MiwgZW5kcG9pbnRPcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgZW5kcG9pbnQ6IGVuZHBvaW50MixcbiAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgZW5kcG9pbnQyKVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgcmVxdWVzdCA9IHdpdGhEZWZhdWx0cyhlbmRwb2ludCwge1xuICBoZWFkZXJzOiB7XG4gICAgXCJ1c2VyLWFnZW50XCI6IGBvY3Rva2l0LXJlcXVlc3QuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWBcbiAgfVxufSk7XG5leHBvcnQge1xuICByZXF1ZXN0XG59O1xuIiwgImV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtcbiAgICAgIHByb2Nlc3MuYXJjaFxuICAgIH0pYDtcbiAgfVxuXG4gIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5pbXBvcnQgeyByZXF1ZXN0IGFzIFJlcXVlc3QyIH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbmltcG9ydCB7IHJlcXVlc3QgYXMgUmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9lcnJvci5qc1xuZnVuY3Rpb24gX2J1aWxkTWVzc2FnZUZvclJlc3BvbnNlRXJyb3JzKGRhdGEpIHtcbiAgcmV0dXJuIGBSZXF1ZXN0IGZhaWxlZCBkdWUgdG8gZm9sbG93aW5nIHJlc3BvbnNlIGVycm9yczpcbmAgKyBkYXRhLmVycm9ycy5tYXAoKGUpID0+IGAgLSAke2UubWVzc2FnZX1gKS5qb2luKFwiXFxuXCIpO1xufVxudmFyIEdyYXBocWxSZXNwb25zZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QyLCBoZWFkZXJzLCByZXNwb25zZSkge1xuICAgIHN1cGVyKF9idWlsZE1lc3NhZ2VGb3JSZXNwb25zZUVycm9ycyhyZXNwb25zZSkpO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3QyO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZXJyb3JzID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgbmFtZSA9IFwiR3JhcGhxbFJlc3BvbnNlRXJyb3JcIjtcbiAgZXJyb3JzO1xuICBkYXRhO1xufTtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbnZhciBOT05fVkFSSUFCTEVfT1BUSU9OUyA9IFtcbiAgXCJtZXRob2RcIixcbiAgXCJiYXNlVXJsXCIsXG4gIFwidXJsXCIsXG4gIFwiaGVhZGVyc1wiLFxuICBcInJlcXVlc3RcIixcbiAgXCJxdWVyeVwiLFxuICBcIm1lZGlhVHlwZVwiXG5dO1xudmFyIEZPUkJJRERFTl9WQVJJQUJMRV9PUFRJT05TID0gW1wicXVlcnlcIiwgXCJtZXRob2RcIiwgXCJ1cmxcIl07XG52YXIgR0hFU19WM19TVUZGSVhfUkVHRVggPSAvXFwvYXBpXFwvdjNcXC8/JC87XG5mdW5jdGlvbiBncmFwaHFsKHJlcXVlc3QyLCBxdWVyeSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgJiYgXCJxdWVyeVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKGBbQG9jdG9raXQvZ3JhcGhxbF0gXCJxdWVyeVwiIGNhbm5vdCBiZSB1c2VkIGFzIHZhcmlhYmxlIG5hbWVgKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCFGT1JCSURERU5fVkFSSUFCTEVfT1BUSU9OUy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgIGBbQG9jdG9raXQvZ3JhcGhxbF0gXCIke2tleX1cIiBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZSBuYW1lYFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJzZWRPcHRpb25zID0gdHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiID8gT2JqZWN0LmFzc2lnbih7IHF1ZXJ5IH0sIG9wdGlvbnMpIDogcXVlcnk7XG4gIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmtleXMoXG4gICAgcGFyc2VkT3B0aW9uc1xuICApLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICBpZiAoTk9OX1ZBUklBQkxFX09QVElPTlMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwYXJzZWRPcHRpb25zW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC52YXJpYWJsZXMpIHtcbiAgICAgIHJlc3VsdC52YXJpYWJsZXMgPSB7fTtcbiAgICB9XG4gICAgcmVzdWx0LnZhcmlhYmxlc1trZXldID0gcGFyc2VkT3B0aW9uc1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgY29uc3QgYmFzZVVybCA9IHBhcnNlZE9wdGlvbnMuYmFzZVVybCB8fCByZXF1ZXN0Mi5lbmRwb2ludC5ERUZBVUxUUy5iYXNlVXJsO1xuICBpZiAoR0hFU19WM19TVUZGSVhfUkVHRVgudGVzdChiYXNlVXJsKSkge1xuICAgIHJlcXVlc3RPcHRpb25zLnVybCA9IGJhc2VVcmwucmVwbGFjZShHSEVTX1YzX1NVRkZJWF9SRUdFWCwgXCIvYXBpL2dyYXBocWxcIik7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QyKHJlcXVlc3RPcHRpb25zKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZS5kYXRhLmVycm9ycykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICAgICAgaGVhZGVyc1trZXldID0gcmVzcG9uc2UuaGVhZGVyc1trZXldO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEdyYXBocWxSZXNwb25zZUVycm9yKFxuICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2UuZGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgfSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocmVxdWVzdDIsIG5ld0RlZmF1bHRzKSB7XG4gIGNvbnN0IG5ld1JlcXVlc3QgPSByZXF1ZXN0Mi5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IG5ld0FwaSA9IChxdWVyeSwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBncmFwaHFsKG5ld1JlcXVlc3QsIHF1ZXJ5LCBvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIG5ld1JlcXVlc3QpLFxuICAgIGVuZHBvaW50OiBuZXdSZXF1ZXN0LmVuZHBvaW50XG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbnZhciBncmFwaHFsMiA9IHdpdGhEZWZhdWx0cyhyZXF1ZXN0LCB7XG4gIGhlYWRlcnM6IHtcbiAgICBcInVzZXItYWdlbnRcIjogYG9jdG9raXQtZ3JhcGhxbC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YFxuICB9LFxuICBtZXRob2Q6IFwiUE9TVFwiLFxuICB1cmw6IFwiL2dyYXBocWxcIlxufSk7XG5mdW5jdGlvbiB3aXRoQ3VzdG9tUmVxdWVzdChjdXN0b21SZXF1ZXN0KSB7XG4gIHJldHVybiB3aXRoRGVmYXVsdHMoY3VzdG9tUmVxdWVzdCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBcIi9ncmFwaHFsXCJcbiAgfSk7XG59XG5leHBvcnQge1xuICBHcmFwaHFsUmVzcG9uc2VFcnJvcixcbiAgZ3JhcGhxbDIgYXMgZ3JhcGhxbCxcbiAgd2l0aEN1c3RvbVJlcXVlc3Rcbn07XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2F1dGguanNcbnZhciBSRUdFWF9JU19JTlNUQUxMQVRJT05fTEVHQUNZID0gL152MVxcLi87XG52YXIgUkVHRVhfSVNfSU5TVEFMTEFUSU9OID0gL15naHNfLztcbnZhciBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUiA9IC9eZ2h1Xy87XG5hc3luYyBmdW5jdGlvbiBhdXRoKHRva2VuKSB7XG4gIGNvbnN0IGlzQXBwID0gdG9rZW4uc3BsaXQoL1xcLi8pLmxlbmd0aCA9PT0gMztcbiAgY29uc3QgaXNJbnN0YWxsYXRpb24gPSBSRUdFWF9JU19JTlNUQUxMQVRJT05fTEVHQUNZLnRlc3QodG9rZW4pIHx8IFJFR0VYX0lTX0lOU1RBTExBVElPTi50ZXN0KHRva2VuKTtcbiAgY29uc3QgaXNVc2VyVG9TZXJ2ZXIgPSBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUi50ZXN0KHRva2VuKTtcbiAgY29uc3QgdG9rZW5UeXBlID0gaXNBcHAgPyBcImFwcFwiIDogaXNJbnN0YWxsYXRpb24gPyBcImluc3RhbGxhdGlvblwiIDogaXNVc2VyVG9TZXJ2ZXIgPyBcInVzZXItdG8tc2VydmVyXCIgOiBcIm9hdXRoXCI7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b2tlblwiLFxuICAgIHRva2VuLFxuICAgIHRva2VuVHlwZVxuICB9O1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1hdXRob3JpemF0aW9uLXByZWZpeC5qc1xuZnVuY3Rpb24gd2l0aEF1dGhvcml6YXRpb25QcmVmaXgodG9rZW4pIHtcbiAgaWYgKHRva2VuLnNwbGl0KC9cXC4vKS5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYGJlYXJlciAke3Rva2VufWA7XG4gIH1cbiAgcmV0dXJuIGB0b2tlbiAke3Rva2VufWA7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9ob29rLmpzXG5hc3luYyBmdW5jdGlvbiBob29rKHRva2VuLCByZXF1ZXN0LCByb3V0ZSwgcGFyYW1ldGVycykge1xuICBjb25zdCBlbmRwb2ludCA9IHJlcXVlc3QuZW5kcG9pbnQubWVyZ2UoXG4gICAgcm91dGUsXG4gICAgcGFyYW1ldGVyc1xuICApO1xuICBlbmRwb2ludC5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSB3aXRoQXV0aG9yaXphdGlvblByZWZpeCh0b2tlbik7XG4gIHJldHVybiByZXF1ZXN0KGVuZHBvaW50KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgY3JlYXRlVG9rZW5BdXRoID0gZnVuY3Rpb24gY3JlYXRlVG9rZW5BdXRoMih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIE5vIHRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGhcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIFRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGggaXMgbm90IGEgc3RyaW5nXCJcbiAgICApO1xuICB9XG4gIHRva2VuID0gdG9rZW4ucmVwbGFjZSgvXih0b2tlbnxiZWFyZXIpICsvaSwgXCJcIik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGF1dGguYmluZChudWxsLCB0b2tlbiksIHtcbiAgICBob29rOiBob29rLmJpbmQobnVsbCwgdG9rZW4pXG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIGNyZWF0ZVRva2VuQXV0aFxufTtcbiIsICJjb25zdCBWRVJTSU9OID0gXCI2LjAuMVwiO1xuZXhwb3J0IHtcbiAgVkVSU0lPTlxufTtcbiIsICJpbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tIFwidW5pdmVyc2FsLXVzZXItYWdlbnRcIjtcbmltcG9ydCBIb29rIGZyb20gXCJiZWZvcmUtYWZ0ZXItaG9va1wiO1xuaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5pbXBvcnQgeyBncmFwaHFsLCB3aXRoQ3VzdG9tUmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9ncmFwaHFsXCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbkF1dGggfSBmcm9tIFwiQG9jdG9raXQvYXV0aC10b2tlblwiO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuL3ZlcnNpb24uanNcIjtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3QgY29uc29sZVdhcm4gPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbmNvbnN0IGNvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbmNvbnN0IHVzZXJBZ2VudFRyYWlsID0gYG9jdG9raXQtY29yZS5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YDtcbmNsYXNzIE9jdG9raXQge1xuICBzdGF0aWMgVkVSU0lPTiA9IFZFUlNJT047XG4gIHN0YXRpYyBkZWZhdWx0cyhkZWZhdWx0cykge1xuICAgIGNvbnN0IE9jdG9raXRXaXRoRGVmYXVsdHMgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1swXSB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgc3VwZXIoZGVmYXVsdHMob3B0aW9ucykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zLnVzZXJBZ2VudCAmJiBkZWZhdWx0cy51c2VyQWdlbnQgPyB7XG4gICAgICAgICAgICAgIHVzZXJBZ2VudDogYCR7b3B0aW9ucy51c2VyQWdlbnR9ICR7ZGVmYXVsdHMudXNlckFnZW50fWBcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9jdG9raXRXaXRoRGVmYXVsdHM7XG4gIH1cbiAgc3RhdGljIHBsdWdpbnMgPSBbXTtcbiAgLyoqXG4gICAqIEF0dGFjaCBhIHBsdWdpbiAob3IgbWFueSkgdG8geW91ciBPY3Rva2l0IGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBBUEkgPSBPY3Rva2l0LnBsdWdpbihwbHVnaW4xLCBwbHVnaW4yLCBwbHVnaW4zLCAuLi4pXG4gICAqL1xuICBzdGF0aWMgcGx1Z2luKC4uLm5ld1BsdWdpbnMpIHtcbiAgICBjb25zdCBjdXJyZW50UGx1Z2lucyA9IHRoaXMucGx1Z2lucztcbiAgICBjb25zdCBOZXdPY3Rva2l0ID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICAgIHN0YXRpYyBwbHVnaW5zID0gY3VycmVudFBsdWdpbnMuY29uY2F0KFxuICAgICAgICBuZXdQbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiAhY3VycmVudFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV3T2N0b2tpdDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBob29rID0gbmV3IEhvb2suQ29sbGVjdGlvbigpO1xuICAgIGNvbnN0IHJlcXVlc3REZWZhdWx0cyA9IHtcbiAgICAgIGJhc2VVcmw6IHJlcXVlc3QuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgcmVxdWVzdDogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdXNhZ2Ugb25seSwgbm8gbmVlZCB0byB0eXBlXG4gICAgICAgIGhvb2s6IGhvb2suYmluZChudWxsLCBcInJlcXVlc3RcIilcbiAgICAgIH0pLFxuICAgICAgbWVkaWFUeXBlOiB7XG4gICAgICAgIHByZXZpZXdzOiBbXSxcbiAgICAgICAgZm9ybWF0OiBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0RGVmYXVsdHMuaGVhZGVyc1tcInVzZXItYWdlbnRcIl0gPSBvcHRpb25zLnVzZXJBZ2VudCA/IGAke29wdGlvbnMudXNlckFnZW50fSAke3VzZXJBZ2VudFRyYWlsfWAgOiB1c2VyQWdlbnRUcmFpbDtcbiAgICBpZiAob3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgICByZXF1ZXN0RGVmYXVsdHMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJldmlld3MpIHtcbiAgICAgIHJlcXVlc3REZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3MgPSBvcHRpb25zLnByZXZpZXdzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgcmVxdWVzdERlZmF1bHRzLmhlYWRlcnNbXCJ0aW1lLXpvbmVcIl0gPSBvcHRpb25zLnRpbWVab25lO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0LmRlZmF1bHRzKHJlcXVlc3REZWZhdWx0cyk7XG4gICAgdGhpcy5ncmFwaHFsID0gd2l0aEN1c3RvbVJlcXVlc3QodGhpcy5yZXF1ZXN0KS5kZWZhdWx0cyhyZXF1ZXN0RGVmYXVsdHMpO1xuICAgIHRoaXMubG9nID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgZGVidWc6IG5vb3AsXG4gICAgICAgIGluZm86IG5vb3AsXG4gICAgICAgIHdhcm46IGNvbnNvbGVXYXJuLFxuICAgICAgICBlcnJvcjogY29uc29sZUVycm9yXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5sb2dcbiAgICApO1xuICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgaWYgKCFvcHRpb25zLmF1dGhTdHJhdGVneSkge1xuICAgICAgaWYgKCFvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcInVuYXV0aGVudGljYXRlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IGNyZWF0ZVRva2VuQXV0aChvcHRpb25zLmF1dGgpO1xuICAgICAgICBob29rLndyYXAoXCJyZXF1ZXN0XCIsIGF1dGguaG9vayk7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgYXV0aFN0cmF0ZWd5LCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBhdXRoID0gYXV0aFN0cmF0ZWd5KFxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgICAgICAgIGxvZzogdGhpcy5sb2csXG4gICAgICAgICAgICAvLyB3ZSBwYXNzIHRoZSBjdXJyZW50IG9jdG9raXQgaW5zdGFuY2UgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgICAgICAgICAgLy8gdG8gYWxsb3cgZm9yIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWdpZXMgdGhhdCByZXR1cm4gYSBuZXcgb2N0b2tpdCBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gdGhhdCBzaGFyZXMgdGhlIHNhbWUgaW50ZXJuYWwgc3RhdGUgYXMgdGhlIGN1cnJlbnQgb25lLiBUaGUgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIHJlcXVpcmVtZW50IGZvciB0aGlzIHdhcyB0aGUgXCJldmVudC1vY3Rva2l0XCIgYXV0aGVudGljYXRpb24gc3RyYXRlZ3lcbiAgICAgICAgICAgIC8vIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9ib3Qvb2N0b2tpdC1hdXRoLXByb2JvdC5cbiAgICAgICAgICAgIG9jdG9raXQ6IHRoaXMsXG4gICAgICAgICAgICBvY3Rva2l0T3B0aW9uczogb3RoZXJPcHRpb25zXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zLmF1dGhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGhvb2sud3JhcChcInJlcXVlc3RcIiwgYXV0aC5ob29rKTtcbiAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgfVxuICAgIGNvbnN0IGNsYXNzQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NDb25zdHJ1Y3Rvci5wbHVnaW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNsYXNzQ29uc3RydWN0b3IucGx1Z2luc1tpXSh0aGlzLCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIC8vIGFzc2lnbmVkIGR1cmluZyBjb25zdHJ1Y3RvclxuICByZXF1ZXN0O1xuICBncmFwaHFsO1xuICBsb2c7XG4gIGhvb2s7XG4gIC8vIFRPRE86IHR5cGUgYG9jdG9raXQuYXV0aGAgYmFzZWQgb24gcGFzc2VkIG9wdGlvbnMuYXV0aFN0cmF0ZWd5XG4gIGF1dGg7XG59XG5leHBvcnQge1xuICBPY3Rva2l0XG59O1xuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgQ2xhc2hTdGF0dXMsIEZpbGVPcFJlY29yZCwgTG9jYWxGaWxlU3RhdHVzLCBSZW1vdGVDaGFuZ2VUeXBlIH0gZnJvbSBcIi4vZml0VHlwZXNcIjtcblxudHlwZSBTdGF0dXMgPSBSZW1vdGVDaGFuZ2VUeXBlIHwgTG9jYWxGaWxlU3RhdHVzXG5cbnR5cGUgRmlsZUxvY2F0aW9uID0gXCJyZW1vdGVcIiB8IFwibG9jYWxcIlxuXG50eXBlIENvbXBhcmlzb25SZXN1bHQ8RW52IGV4dGVuZHMgRmlsZUxvY2F0aW9uPiA9IHtcbiAgICBwYXRoOiBzdHJpbmcsIFxuICAgIHN0YXR1czogRW52IGV4dGVuZHMgXCJsb2NhbFwiID8gTG9jYWxGaWxlU3RhdHVzOiBSZW1vdGVDaGFuZ2VUeXBlXG4gICAgY3VycmVudFNoYT86IHN0cmluZ1xuICAgIGV4dGVuc2lvbj86IHN0cmluZ1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZU9yTnVsbChvYmo6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIGtleTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpID8gb2JqW2tleV0gOiBudWxsO1xufVxuXG5cbi8vIGNvbXBhcmUgY3VycmVudFNoYSB3aXRoIHN0b3JlZFNoYSBhbmQgY2hlY2sgZm9yIGRpZmZlcmVuY2VzLCBmaWxlcyBvbmx5IGluIGN1cnJlbnRTaGFcbi8vICBhcmUgY29uc2lkZXJkIGFkZGVkLCB3aGlsZSBmaWxlcyBvbmx5IGluIHN0b3JlZFNoYSBhcmUgY29uc2lkZXJlZCByZW1vdmVkXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVNoYTxFbnYgZXh0ZW5kcyBcInJlbW90ZVwiIHwgXCJsb2NhbFwiPihcbiAgICBjdXJyZW50U2hhTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBcbiAgICBzdG9yZWRTaGFNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZW52OiBFbnYpOiBDb21wYXJpc29uUmVzdWx0PEVudj5bXSB7XG4gICAgICAgIGNvbnN0IGRldGVybWluZVN0YXR1cyA9IChjdXJyZW50U2hhOiBzdHJpbmcgfCBudWxsLCBzdG9yZWRTaGE6IHN0cmluZyB8IG51bGwpOiBTdGF0dXMgfCBudWxsICA9PiBcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTaGEgJiYgc3RvcmVkU2hhICYmIGN1cnJlbnRTaGEgIT09IHN0b3JlZFNoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnYgPT09IFwibG9jYWxcIiA/IFwiY2hhbmdlZFwiIDogXCJNT0RJRklFRFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U2hhICYmICFzdG9yZWRTaGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW52ID09PSBcImxvY2FsXCIgPyBcImNyZWF0ZWRcIiA6IFwiQURERURcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRTaGEgJiYgc3RvcmVkU2hhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudiA9PT0gXCJsb2NhbFwiID8gXCJkZWxldGVkXCIgOiBcIlJFTU9WRURcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoeyAuLi5jdXJyZW50U2hhTWFwLCAuLi5zdG9yZWRTaGFNYXAgfSkuZmxhdE1hcCgocGF0aCk6IENvbXBhcmlzb25SZXN1bHQ8RW52PltdID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50U2hhLCBzdG9yZWRTaGFdID0gW2dldFZhbHVlT3JOdWxsKGN1cnJlbnRTaGFNYXAsIHBhdGgpLCBnZXRWYWx1ZU9yTnVsbChzdG9yZWRTaGFNYXAsIHBhdGgpXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGRldGVybWluZVN0YXR1cyhjdXJyZW50U2hhLCBzdG9yZWRTaGEpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyBhcyBFbnYgZXh0ZW5kcyBcImxvY2FsXCIgPyBMb2NhbEZpbGVTdGF0dXMgOiBSZW1vdGVDaGFuZ2VUeXBlLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2hhOiBjdXJyZW50U2hhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRyYWN0RXh0ZW5zaW9uKHBhdGgpXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgY29uc3QgUkVDT0dOSVpFRF9CSU5BUllfRVhUID0gW1wicG5nXCIsIFwianBnXCIsIFwianBlZ1wiLCBcInBkZlwiXVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEV4dGVuc2lvbihwYXRoOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBwYXRoLm1hdGNoKC9bXi5dKyQvKT8uWzBdO1xufVxuXG4vLyBVc2luZyBmaWxlIGV4dGVuc2lvbiB0byBkZXRlcm1pbmUgZW5jb2Rpbmcgb2YgZmlsZXMgKHdvcmtzIGluIG1vc3QgY2FzZXMpXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZUVuY29kaW5nKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gcGF0aC5tYXRjaCgvW14uXSskLyk/LlswXTtcbiAgICBjb25zdCBpc0JpbmFyeSA9IGV4dGVuc2lvbiAmJiBSRUNPR05JWkVEX0JJTkFSWV9FWFQuaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiYmFzZTY0XCJcbiAgICB9IFxuICAgIHJldHVybiBcInV0Zi04XCJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEVxdWFsPFQ+KGFycjE6IEFycmF5PFQ+LCBhcnIyOiBBcnJheTxUPikge1xuICAgIGNvbnN0IHNldDEgPSBuZXcgU2V0KGFycjEpO1xuICAgIGNvbnN0IHNldDIgPSBuZXcgU2V0KGFycjIpO1xuICAgIGNvbnN0IGlzRXF1YWwgPSBzZXQxLnNpemUgPT09IHNldDIuc2l6ZSAmJiBbLi4uc2V0MV0uZXZlcnkodmFsdWUgPT4gc2V0Mi5oYXModmFsdWUpKTtcbiAgICByZXR1cm4gaXNFcXVhbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvXFxyP1xcbnxcXHJ8XFxuL2csICcnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dGaWxlT3BzUmVjb3JkKHJlY29yZHM6IEFycmF5PHtoZWFkaW5nOiBzdHJpbmcsIG9wczogRmlsZU9wUmVjb3JkW119Pik6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKHJlY29yZHMpXG4gICAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwIHx8IHJlY29yZHMuZXZlcnkocj0+ci5vcHMubGVuZ3RoPT09MCkpIHtyZXR1cm59XG4gICAgY29uc3QgZmlsZU9wc05vdGljZSA9IG5ldyBOb3RpY2UoXCJcIiwgMClcbiAgICByZWNvcmRzLm1hcChyZWNvcmRTZXQgPT4ge1xuICAgICAgICBpZiAocmVjb3JkU2V0Lm9wcy5sZW5ndGggPT09IDApIHtyZXR1cm59XG4gICAgICAgIGNvbnN0IGhlYWRpbmcgPSBmaWxlT3BzTm90aWNlLm5vdGljZUVsLmNyZWF0ZUVsKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbHM6IFwiZmlsZS1jaGFuZ2VzLWhlYWRpbmdcIlxuICAgICAgICB9KVxuICAgICAgICBoZWFkaW5nLnNldFRleHQoYCR7cmVjb3JkU2V0LmhlYWRpbmd9XFxuYClcbiAgICAgICAgY29uc3QgZmlsZUNoYW5nZXMgPSB7XG4gICAgICAgICAgICBjcmVhdGVkOiBbXSBhcyBBcnJheTxzdHJpbmc+LCBcbiAgICAgICAgICAgIGNoYW5nZWQ6IFtdIGFzIEFycmF5PHN0cmluZz4sIFxuICAgICAgICAgICAgZGVsZXRlZDogW10gYXMgQXJyYXk8c3RyaW5nPlxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgcmVjb3JkU2V0Lm9wcykge1xuICAgICAgICAgICAgZmlsZUNoYW5nZXNbb3Auc3RhdHVzXS5wdXNoKG9wLnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbY2hhbmdlVHlwZSwgcGF0aHNdIG9mIE9iamVjdC5lbnRyaWVzKGZpbGVDaGFuZ2VzKSkge1xuICAgICAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge2NvbnRpbnVlfVxuICAgICAgICAgICAgY29uc3QgaGVhZGluZyA9IGZpbGVPcHNOb3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoXCJzcGFuXCIpXG4gICAgICAgICAgICBoZWFkaW5nLnNldFRleHQoYCR7Y2hhbmdlVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNoYW5nZVR5cGUuc2xpY2UoMSl9XFxuYClcbiAgICAgICAgICAgIGhlYWRpbmcuYWRkQ2xhc3MoYGZpbGUtY2hhbmdlcy1zdWJoZWFkaW5nYClcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gZmlsZU9wc05vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBcImZpbGUtdXBkYXRlLXJvd1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc2V0VGV4dChgJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLmFkZENsYXNzKGBmaWxlLSR7Y2hhbmdlVHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93VW5hcHBsaWVkQ29uZmxpY3RzKGNsYXNoZWRGaWxlczogQXJyYXk8Q2xhc2hTdGF0dXM+KTogdm9pZCB7XG4gICAgaWYgKGNsYXNoZWRGaWxlcy5sZW5ndGggPT09IDApIHtyZXR1cm59XG4gICAgY29uc3QgbG9jYWxTdGF0dXNNYXAgPSB7XG4gICAgICAgIGNyZWF0ZWQ6IFwiY3JlYXRlXCIsXG4gICAgICAgIGNoYW5nZWQ6IFwiY2hhbmdlXCIsXG4gICAgICAgIGRlbGV0ZWQ6IFwiZGVsZXRlXCJcbiAgICB9XG4gICAgY29uc3QgcmVtb3RlU3RhdHVzTWFwID0ge1xuICAgICAgICBBRERFRDogIFwiY3JlYXRlXCIsXG4gICAgICAgIE1PRElGSUVEOiBcImNoYW5nZVwiLFxuICAgICAgICBSRU1PVkVEOiBcImRlbGV0ZVwiXG4gICAgfVxuICAgIGNvbnN0IGNvbmZsaWN0Tm90aWNlID0gbmV3IE5vdGljZShcIlwiLCAwKVxuICAgIGNvbnN0IGhlYWRpbmcgPSBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcInNwYW5cIilcbiAgICBoZWFkaW5nLnNldFRleHQoYENoYW5nZSBjb25mbGljdHM6XFxuYClcbiAgICBoZWFkaW5nLmFkZENsYXNzKGBmaWxlLWNoYW5nZXMtc3ViaGVhZGluZ2ApXG4gICAgY29uc3QgY29uZmxpY3RTdGF0dXMgPSBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVEaXYoe1xuICAgICAgICBjbHM6IFwiZmlsZS1jb25mbGljdC1yb3dcIlxuICAgIH0pO1xuICAgIGNvbmZsaWN0U3RhdHVzLmNyZWF0ZURpdigpLnNldFRleHQoXCJMb2NhbFwiKVxuXHRjb25mbGljdFN0YXR1cy5jcmVhdGVEaXYoKS5zZXRUZXh0KFwiUmVtb3RlXCIpXG4gICAgZm9yIChjb25zdCBjbGFzaCBvZiBjbGFzaGVkRmlsZXMpIHtcbiAgICAgICAgY29uc3QgY29uZmxpY3RJdGVtID0gY29uZmxpY3ROb3RpY2Uubm90aWNlRWwuY3JlYXRlRGl2KHtcbiAgICAgICAgICAgIGNsczogXCJmaWxlLWNvbmZsaWN0LXJvd1wiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25mbGljdEl0ZW0uY3JlYXRlRGl2KHtcbiAgICAgICAgICAgIGNsczogYGZpbGUtY29uZmxpY3QtJHtsb2NhbFN0YXR1c01hcFtjbGFzaC5sb2NhbFN0YXR1c119YFxuICAgICAgICB9KTtcbiAgICAgICAgY29uZmxpY3RJdGVtLmNyZWF0ZURpdihcImRpdlwiKVxuICAgICAgICAgICAgLnNldFRleHQoY2xhc2gucGF0aCk7XG4gICAgICAgIGNvbmZsaWN0SXRlbS5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgY2xzOiBgZmlsZS1jb25mbGljdC0ke3JlbW90ZVN0YXR1c01hcFtjbGFzaC5yZW1vdGVTdGF0dXNdfWBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGZvb3RlciA9IGNvbmZsaWN0Tm90aWNlLm5vdGljZUVsLmNyZWF0ZURpdih7XG4gICAgICAgIGNsczogXCJmaWxlLWNvbmZsaWN0LXJvd1wiXG4gICAgfSlcbiAgICBmb290ZXIuc2V0VGV4dChcIk5vdGU6XCIpXG4gICAgZm9vdGVyLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtjbHM6IFwiZmlsZS1jb25mbGljdC1ub3RlXCJ9KVxuICAgICAgICAuc2V0VGV4dChcIlJlbW90ZSBjaGFuZ2VzIGluIF9maXRcIilcbiAgICBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtjbHM6IFwiZmlsZS1jb25mbGljdC1ub3RlXCJ9KVxuICAgICAgICAuc2V0VGV4dChcIl9maXQgZm9sZGVyIGlzIG92ZXJ3cml0dGVuIG9uIGNvbmZsaWN0LCBjb3B5IG5lZWRlZCBjaGFuZ2VzIG91dHNpZGUgX2ZpdC5cIilcbn1cbiIsICJpbXBvcnQgeyBMb2NhbFN0b3JlcywgRml0U2V0dGluZ3MgfSBmcm9tIFwibWFpblwiXG5pbXBvcnQgeyBPY3Rva2l0IH0gZnJvbSBcIkBvY3Rva2l0L2NvcmVcIlxuaW1wb3J0IHsgUkVDT0dOSVpFRF9CSU5BUllfRVhULCBjb21wYXJlU2hhIH0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSBcIi4vdmF1bHRPcHNcIlxuaW1wb3J0IHsgTG9jYWxDaGFuZ2UsIExvY2FsRmlsZVN0YXR1cywgUmVtb3RlQ2hhbmdlLCBSZW1vdGVDaGFuZ2VUeXBlIH0gZnJvbSBcIi4vZml0VHlwZXNcIlxuaW1wb3J0IHsgYXJyYXlCdWZmZXJUb0Jhc2U2NCB9IGZyb20gXCJvYnNpZGlhblwiXG5cblxuXG5leHBvcnQgdHlwZSBUcmVlTm9kZSA9IHtcbiAgICBwYXRoOiBzdHJpbmcsIFxuICAgIG1vZGU6IFwiMTAwNjQ0XCIgfCBcIjEwMDc1NVwiIHwgXCIwNDAwMDBcIiB8IFwiMTYwMDAwXCIgfCBcIjEyMDAwMFwiIHwgdW5kZWZpbmVkLCBcbiAgICB0eXBlOiBcImNvbW1pdFwiIHwgXCJibG9iXCIgfCBcInRyZWVcIiB8IHVuZGVmaW5lZCwgXG4gICAgc2hhOiBzdHJpbmcgfCBudWxsfVxuXG50eXBlIE9jdG9raXRDYWxsTWV0aG9kcyA9IHtcbiAgICBnZXRVc2VyOiAoKSA9PiBQcm9taXNlPHtvd25lcjogc3RyaW5nLCBhdmF0YXJVcmw6IHN0cmluZ30+XG4gICAgZ2V0UmVwb3M6ICgpID0+IFByb21pc2U8c3RyaW5nW10+XG4gICAgZ2V0UmVmOiAocmVmOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGdldFRyZWU6ICh0cmVlX3NoYTogc3RyaW5nKSA9PiBQcm9taXNlPFRyZWVOb2RlW10+XG4gICAgZ2V0Q29tbWl0VHJlZVNoYTogKHJlZjogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgICBnZXRSZW1vdGVUcmVlU2hhOiAodHJlZV9zaGE6IHN0cmluZykgPT4gUHJvbWlzZTx7W2s6c3RyaW5nXTogc3RyaW5nfT5cbiAgICBjcmVhdGVCbG9iOiAoY29udGVudDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSA9PlByb21pc2U8c3RyaW5nPlxuICAgIGNyZWF0ZVRyZWVOb2RlRnJvbUZpbGU6ICh7cGF0aCwgc3RhdHVzLCBleHRlbnNpb259OiBMb2NhbENoYW5nZSwgcmVtb3RlVHJlZTogVHJlZU5vZGVbXSkgPT4gUHJvbWlzZTxUcmVlTm9kZXxudWxsPlxuICAgIGNyZWF0ZUNvbW1pdDogKHRyZWVTaGE6IHN0cmluZywgcGFyZW50U2hhOiBzdHJpbmcpID0+UHJvbWlzZTxzdHJpbmc+XG4gICAgdXBkYXRlUmVmOiAoc2hhOiBzdHJpbmcsIHJlZjogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgICBnZXRCbG9iOiAoZmlsZV9zaGE6c3RyaW5nKSA9PlByb21pc2U8c3RyaW5nPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGaXQgZXh0ZW5kcyBPY3Rva2l0Q2FsbE1ldGhvZHN7XG4gICAgb3duZXI6IHN0cmluZ1xuICAgIHJlcG86IHN0cmluZ1xuICAgIGJyYW5jaDogc3RyaW5nXG4gICAgaGVhZGVyczoge1trOiBzdHJpbmddOiBzdHJpbmd9XG4gICAgZGV2aWNlTmFtZTogc3RyaW5nXG4gICAgbG9jYWxTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblx0bGFzdEZldGNoZWRDb21taXRTaGE6IHN0cmluZyB8IG51bGxcblx0bGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBvY3Rva2l0OiBPY3Rva2l0XG4gICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9uc1xuICAgIGZpbGVTaGExOiAocGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbn1cblxuLy8gRGVmaW5lIGEgY3VzdG9tIEh0dHBFcnJvciBjbGFzcyB0aGF0IGV4dGVuZHMgRXJyb3JcbmV4cG9ydCBjbGFzcyBPY3Rva2l0SHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHNvdXJjZToga2V5b2YgT2N0b2tpdENhbGxNZXRob2RzXG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBzb3VyY2U6IGtleW9mIE9jdG9raXRDYWxsTWV0aG9kcykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0h0dHBFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpdCBpbXBsZW1lbnRzIElGaXQge1xuICAgIG93bmVyOiBzdHJpbmdcbiAgICByZXBvOiBzdHJpbmdcbiAgICBhdXRoOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBicmFuY2g6IHN0cmluZ1xuICAgIGhlYWRlcnM6IHtbazogc3RyaW5nXTogc3RyaW5nfVxuICAgIGRldmljZU5hbWU6IHN0cmluZ1xuICAgIGxvY2FsU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG5cdGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgb2N0b2tpdDogT2N0b2tpdFxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnNcblxuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZzogRml0U2V0dGluZ3MsIGxvY2FsU3RvcmVzOiBMb2NhbFN0b3JlcywgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9ucykge1xuICAgICAgICB0aGlzLmxvYWRTZXR0aW5ncyhzZXR0aW5nKVxuICAgICAgICB0aGlzLmxvYWRMb2NhbFN0b3JlKGxvY2FsU3RvcmVzKVxuICAgICAgICB0aGlzLnZhdWx0T3BzID0gdmF1bHRPcHNcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gSGFjayB0byBkaXNhYmxlIGNhY2hpbmcgd2hpY2ggbGVhZHMgdG8gaW5jb25zaXN0ZW5jeSBmb3JcbiAgICAgICAgICAgIC8vIHJlYWQgYWZ0ZXIgd3JpdGUgaHR0cHM6Ly9naXRodWIuY29tL29jdG9raXQvb2N0b2tpdC5qcy9pc3N1ZXMvODkwXG4gICAgICAgICAgICBcIklmLU5vbmUtTWF0Y2hcIjogJycsIFxuICAgICAgICAgICAgJ1gtR2l0SHViLUFwaS1WZXJzaW9uJzogJzIwMjItMTEtMjgnXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgbG9hZFNldHRpbmdzKHNldHRpbmc6IEZpdFNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMub3duZXIgPSBzZXR0aW5nLm93bmVyXG4gICAgICAgIHRoaXMucmVwbyA9IHNldHRpbmcucmVwb1xuICAgICAgICB0aGlzLmJyYW5jaCA9IHNldHRpbmcuYnJhbmNoXG4gICAgICAgIHRoaXMuZGV2aWNlTmFtZSA9IHNldHRpbmcuZGV2aWNlTmFtZVxuICAgICAgICB0aGlzLm9jdG9raXQgPSBuZXcgT2N0b2tpdCh7YXV0aDogc2V0dGluZy5wYXR9KVxuICAgIH1cbiAgICBcbiAgICBsb2FkTG9jYWxTdG9yZShsb2NhbFN0b3JlOiBMb2NhbFN0b3Jlcykge1xuICAgICAgICB0aGlzLmxvY2FsU2hhID0gbG9jYWxTdG9yZS5sb2NhbFNoYVxuICAgICAgICB0aGlzLmxhc3RGZXRjaGVkQ29tbWl0U2hhID0gbG9jYWxTdG9yZS5sYXN0RmV0Y2hlZENvbW1pdFNoYVxuICAgICAgICB0aGlzLmxhc3RGZXRjaGVkUmVtb3RlU2hhID0gbG9jYWxTdG9yZS5sYXN0RmV0Y2hlZFJlbW90ZVNoYVxuICAgIH1cbiAgICBcbiAgICBhc3luYyBmaWxlU2hhMShmaWxlQ29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGhhc2hCdWYgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTEnLCBlbmMuZW5jb2RlKGZpbGVDb250ZW50KSlcbiAgICAgICAgY29uc3QgaGFzaEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShoYXNoQnVmKSk7XG4gICAgICAgIGNvbnN0IGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiBoYXNoSGV4O1xuICAgIH1cblxuICAgIGFzeW5jIGNvbXB1dGVGaWxlTG9jYWxTaGEocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgLy8gTm90ZTogb25seSBzdXBwb3J0IFRGaWxlIG5vdywgaW52ZXN0aWdhdGUgbmVlZCBmb3Igc3VwcG9ydGluZyBURm9sZGVyIGxhdGVyIG9uXG4gICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLmdldFRGaWxlKHBhdGgpIFxuXHRcdC8vIGNvbXB1dGUgc2hhMSBiYXNlZCBvbiBwYXRoIGFuZCBmaWxlIGNvbnRlbnRcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZztcbiAgICAgICAgaWYgKFJFQ09HTklaRURfQklOQVJZX0VYVC5pbmNsdWRlcyhmaWxlLmV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQucmVhZEJpbmFyeShmaWxlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LnJlYWQoZmlsZSlcbiAgICAgICAgfVxuXHRcdHJldHVybiBhd2FpdCB0aGlzLmZpbGVTaGExKHBhdGggKyBjb250ZW50KVxuXHR9XG5cblx0YXN5bmMgY29tcHV0ZUxvY2FsU2hhKCk6IFByb21pc2U8e1trOnN0cmluZ106c3RyaW5nfT4ge1xuXHRcdGNvbnN0IHBhdGhzID0gdGhpcy52YXVsdE9wcy52YXVsdC5nZXRGaWxlcygpLm1hcChmPT57XG4gICAgICAgICAgICAvLyBpZ25vcmUgbG9jYWwgZmlsZXMgaW4gdGhlIF9maXQvIGRpcmVjdG9yeVxuICAgICAgICAgICAgcmV0dXJuIGYucGF0aC5zdGFydHNXaXRoKFwiX2ZpdC9cIikgPyBudWxsIDogZi5wYXRoXG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKVxuXHRcdHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG5cdFx0XHRhd2FpdCBQcm9taXNlLmFsbChcblx0XHRcdFx0cGF0aHMubWFwKGFzeW5jIChwOiBzdHJpbmcpOiBQcm9taXNlPFtzdHJpbmcsIHN0cmluZ10+ID0+e1xuXHRcdFx0XHRcdHJldHVybiBbcCwgYXdhaXQgdGhpcy5jb21wdXRlRmlsZUxvY2FsU2hhKHApXVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdClcblx0fVxuXG4gICAgYXN5bmMgcmVtb3RlVXBkYXRlZCgpOiBQcm9taXNlPHtyZW1vdGVDb21taXRTaGE6IHN0cmluZywgdXBkYXRlZDogYm9vbGVhbn0+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlQ29tbWl0U2hhID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RSZW1vdGVDb21taXRTaGEoKVxuICAgICAgICByZXR1cm4ge3JlbW90ZUNvbW1pdFNoYSwgdXBkYXRlZDogcmVtb3RlQ29tbWl0U2hhICE9PSB0aGlzLmxhc3RGZXRjaGVkQ29tbWl0U2hhfVxuICAgIH1cblxuICAgIGFzeW5jIGdldExvY2FsQ2hhbmdlcyhjdXJyZW50TG9jYWxTaGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUHJvbWlzZTxMb2NhbENoYW5nZVtdPiB7XG4gICAgICAgIGlmICghY3VycmVudExvY2FsU2hhKSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxTaGEgPSBhd2FpdCB0aGlzLmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYWxDaGFuZ2VzID0gY29tcGFyZVNoYShjdXJyZW50TG9jYWxTaGEsIHRoaXMubG9jYWxTaGEsIFwibG9jYWxcIilcbiAgICAgICAgcmV0dXJuIGxvY2FsQ2hhbmdlc1xuICAgIH1cblxuICAgIGFzeW5jIGdldFJlbW90ZUNoYW5nZXMocmVtb3RlVHJlZVNoYToge1trOiBzdHJpbmddOiBzdHJpbmd9KTogUHJvbWlzZTxSZW1vdGVDaGFuZ2VbXT4ge1xuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gY29tcGFyZVNoYShyZW1vdGVUcmVlU2hhLCB0aGlzLmxhc3RGZXRjaGVkUmVtb3RlU2hhLCBcInJlbW90ZVwiKVxuICAgICAgICByZXR1cm4gcmVtb3RlQ2hhbmdlc1xuICAgIH1cblxuICAgIGdldENsYXNoZWRDaGFuZ2VzKGxvY2FsQ2hhbmdlczogTG9jYWxDaGFuZ2VbXSwgcmVtb3RlQ2hhbmdlczpSZW1vdGVDaGFuZ2VbXSk6IEFycmF5PHtwYXRoOiBzdHJpbmcsIGxvY2FsU3RhdHVzOiBMb2NhbEZpbGVTdGF0dXMsIHJlbW90ZVN0YXR1czogUmVtb3RlQ2hhbmdlVHlwZX0+IHtcbiAgICAgICAgY29uc3QgbG9jYWxDaGFuZ2VQYXRocyA9IGxvY2FsQ2hhbmdlcy5tYXAoYz0+Yy5wYXRoKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VQYXRocyA9IHJlbW90ZUNoYW5nZXMubWFwKGM9PmMucGF0aClcbiAgICAgICAgY29uc3QgY2xhc2hlZEZpbGVzID0gbG9jYWxDaGFuZ2VQYXRocy5tYXAoXG4gICAgICAgICAgICAocGF0aCwgbG9jYWxJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZGV4ID0gcmVtb3RlQ2hhbmdlUGF0aHMuaW5kZXhPZihwYXRoKVxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBsb2NhbEluZGV4LCByZW1vdGVJbmRleH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH0pLmZpbHRlcihCb29sZWFuKSBhcyBBcnJheTx7cGF0aDogc3RyaW5nLCBsb2NhbEluZGV4OiBudW1iZXIsIHJlbW90ZUluZGV4Om51bWJlcn0+XG4gICAgICAgIHJldHVybiBjbGFzaGVkRmlsZXMubWFwKFxuICAgICAgICAgICAgKHtwYXRoLCBsb2NhbEluZGV4LCByZW1vdGVJbmRleH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXR1czogbG9jYWxDaGFuZ2VzW2xvY2FsSW5kZXhdLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU3RhdHVzOiByZW1vdGVDaGFuZ2VzW3JlbW90ZUluZGV4XS5zdGF0dXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIGFzeW5jIGdldFVzZXIoKTogUHJvbWlzZTx7b3duZXI6IHN0cmluZywgYXZhdGFyVXJsOiBzdHJpbmd9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHtvd25lcjogcmVzcG9uc2UubG9naW4sIGF2YXRhclVybDpyZXNwb25zZS5hdmF0YXJfdXJsfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9jdG9raXRIdHRwRXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhdHVzLCBcImdldFVzZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRSZXBvcygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvdXNlci9yZXBvc2AsIHtcbiAgICAgICAgICAgICAgICAgICAgYWZmaWxpYXRpb246IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChyID0+IHIubmFtZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPY3Rva2l0SHR0cEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YXR1cywgXCJnZXRSZXBvc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEJyYW5jaGVzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHtkYXRhOiByZXNwb25zZX0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgICAgICBgR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlc2AsIFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChyID0+IHIubmFtZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPY3Rva2l0SHR0cEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YXR1cywgXCJnZXRSZXBvc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFJlZihyZWY6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZi97cmVmfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiByZWYsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vYmplY3Quc2hhXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2N0b2tpdEh0dHBFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGF0dXMsIFwiZ2V0UmVmXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBzaGEgb2YgdGhlIGxhdGVzdCBjb21taXQgaW4gdGhlIGRlZmF1bHQgYnJhbmNoIChzZXQgYnkgdXNlciBpbiBzZXR0aW5nKVxuICAgIGFzeW5jIGdldExhdGVzdFJlbW90ZUNvbW1pdFNoYShyZWYgPSBgaGVhZHMvJHt0aGlzLmJyYW5jaH1gKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UmVmKHJlZilcbiAgICB9XG5cbiAgICAvLyByZWYgQ2FuIGJlIGEgY29tbWl0IFNIQSwgYnJhbmNoIG5hbWUgKGhlYWRzL0JSQU5DSF9OQU1FKSwgb3IgdGFnIG5hbWUgKHRhZ3MvVEFHX05BTUUpLCBcbiAgICAvLyByZWZlcnMgdG8gaHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL0dpdC1JbnRlcm5hbHMtR2l0LVJlZmVyZW5jZXNcbiAgICBhc3luYyBnZXRDb21taXRUcmVlU2hhKHJlZjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3Qge2RhdGE6IGNvbW1pdH0gPSAgYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoIFxuICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfWAsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBjb21taXQuY29tbWl0LnRyZWUuc2hhXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VHJlZSh0cmVlX3NoYTogc3RyaW5nKTogUHJvbWlzZTxUcmVlTm9kZVtdPiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogdHJlZSB9ID0gIGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RyZWVzL3t0cmVlX3NoYX1gLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIHRyZWVfc2hhLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiAndHJ1ZScsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRyZWUudHJlZSBhcyBUcmVlTm9kZVtdXG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSByZW1vdGUgdHJlZSBzaGEgaW4gdGhlIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggbG9jYWwgc3RvcmVcbiAgICBhc3luYyBnZXRSZW1vdGVUcmVlU2hhKHRyZWVfc2hhOiBzdHJpbmcpOiBQcm9taXNlPHtbazpzdHJpbmddOiBzdHJpbmd9PiB7XG4gICAgICAgIGNvbnN0IHJlbW90ZVRyZWUgPSBhd2FpdCB0aGlzLmdldFRyZWUodHJlZV9zaGEpXG4gICAgICAgIGNvbnN0IHJlbW90ZVNoYSA9IE9iamVjdC5mcm9tRW50cmllcyhyZW1vdGVUcmVlLm1hcCgobm9kZTogVHJlZU5vZGUpIDogW3N0cmluZywgc3RyaW5nXSB8IG51bGw9PntcbiAgICAgICAgICAgIC8vIGN1cnJlbnRseSBpZ25vcmluZyBkaXJlY3RvcnkgY2hhbmdlcywgaWYgeW91J2QgbGlrZSB0byB1cGxvYWQgYSBuZXcgZGlyZWN0b3J5LCBcbiAgICAgICAgICAgIC8vIGEgcXVpY2sgaGFjayB3b3VsZCBiZSBjcmVhdGluZyBhbiBlbXB0eSBmaWxlIGluc2lkZVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZT09XCJibG9iXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUucGF0aCB8fCAhbm9kZS5zaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCBvciBzaGEgbm90IGZvdW5kIGZvciBibG9iIG5vZGUgaW4gcmVtb3RlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgY2hhbmdlcyBpbiB0aGUgX2ZpdC8gZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGF0aC5zdGFydHNXaXRoKFwiX2ZpdC9cIikpIHtyZXR1cm4gbnVsbH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW25vZGUucGF0aCwgbm9kZS5zaGFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgW3N0cmluZywgc3RyaW5nXVtdKVxuICAgICAgICByZXR1cm4gcmVtb3RlU2hhXG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlQmxvYihjb250ZW50OiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7ZGF0YTogYmxvYn0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvYmxvYnNgLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIGNvbnRlbnQsIFxuICAgICAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgICAgIFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYmxvYi5zaGFcbiAgICB9XG5cblxuICAgIGFzeW5jIGNyZWF0ZVRyZWVOb2RlRnJvbUZpbGUoe3BhdGgsIHN0YXR1cywgZXh0ZW5zaW9ufTogTG9jYWxDaGFuZ2UsIHJlbW90ZVRyZWU6IEFycmF5PFRyZWVOb2RlPik6IFByb21pc2U8VHJlZU5vZGV8bnVsbD4ge1xuXHRcdGlmIChzdGF0dXMgPT09IFwiZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAvLyBza2lwIGNyZWF0aW5nIGRlbGV0aW9uIG5vZGUgaWYgZmlsZSBub3QgZm91bmQgb24gcmVtb3RlXG4gICAgICAgICAgICBpZiAocmVtb3RlVHJlZS5ldmVyeShub2RlID0+IG5vZGUucGF0aCAhPT0gcGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0bW9kZTogJzEwMDY0NCcsXG5cdFx0XHRcdHR5cGU6ICdibG9iJyxcblx0XHRcdFx0c2hhOiBudWxsXG5cdFx0XHR9XG5cdFx0fVxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy52YXVsdE9wcy5nZXRURmlsZShwYXRoKVxuXHRcdGxldCBlbmNvZGluZzogc3RyaW5nO1xuXHRcdGxldCBjb250ZW50OiBzdHJpbmcgXG4gICAgICAgIC8vIFRPRE8gY2hlY2sgd2hldGhlciBldmVyeSBmaWxlcyBpbmNsdWRpbmcgbWQgY2FuIGJlIHJlYWQgdXNpbmcgcmVhZEJpbmFyeSB0byByZWR1Y2UgY29kZSBjb21wbGV4aXR5XG5cdFx0aWYgKGV4dGVuc2lvbiAmJiBSRUNPR05JWkVEX0JJTkFSWV9FWFQuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuXHRcdFx0ZW5jb2RpbmcgPSBcImJhc2U2NFwiXG5cblx0XHRcdGNvbnN0IGZpbGVBcnJheUJ1ZiA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQucmVhZEJpbmFyeShmaWxlKVxuXHRcdFx0Y29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGZpbGVBcnJheUJ1Zik7XG5cdFx0XHRsZXQgYmluYXJ5U3RyaW5nID0gJyc7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4QXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhBcnJheVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRjb250ZW50ID0gYnRvYShiaW5hcnlTdHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbmNvZGluZyA9ICd1dGYtOCdcblx0XHRcdGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LnJlYWQoZmlsZSlcblx0XHR9XG5cdFx0Y29uc3QgYmxvYlNoYSA9IGF3YWl0IHRoaXMuY3JlYXRlQmxvYihjb250ZW50LCBlbmNvZGluZylcbiAgICAgICAgLy8gc2tpcCBjcmVhdGluZyBub2RlIGlmIGZpbGUgZm91bmQgb24gcmVtb3RlIGlzIHRoZSBzYW1lIGFzIHRoZSBjcmVhdGVkIGJsb2JcbiAgICAgICAgaWYgKHJlbW90ZVRyZWUuc29tZShub2RlID0+IG5vZGUucGF0aCA9PT0gcGF0aCAmJiBub2RlLnNoYSA9PT0gYmxvYlNoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0cGF0aDogcGF0aCxcblx0XHRcdG1vZGU6ICcxMDA2NDQnLFxuXHRcdFx0dHlwZTogJ2Jsb2InLFxuXHRcdFx0c2hhOiBibG9iU2hhLFxuXHRcdH1cblx0fVxuXG4gICAgYXN5bmMgY3JlYXRlVHJlZShcbiAgICAgICAgdHJlZU5vZGVzOiBBcnJheTxUcmVlTm9kZT4sXG4gICAgICAgIGJhc2VfdHJlZV9zaGE6IHN0cmluZyk6IFxuICAgICAgICBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICAgICAgY29uc3Qge2RhdGE6IG5ld1RyZWV9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYFBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90cmVlc2AsIFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogdHJlZU5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBiYXNlX3RyZWU6IGJhc2VfdHJlZV9zaGEsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlLnNoYVxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdCh0cmVlU2hhOiBzdHJpbmcsIHBhcmVudFNoYTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDb21taXQgZnJvbSAke3RoaXMuZGV2aWNlTmFtZX0gb24gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCl9YFxuICAgICAgICBjb25zdCB7IGRhdGE6IGNyZWF0ZWRDb21taXQgfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYFBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9jb21taXRzYCAsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRyZWU6IHRyZWVTaGEsXG4gICAgICAgICAgICBwYXJlbnRzOiBbcGFyZW50U2hhXSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gY3JlYXRlZENvbW1pdC5zaGFcbiAgICB9XG5cbiAgICBhc3luYyB1cGRhdGVSZWYoc2hhOiBzdHJpbmcsIHJlZiA9IGBoZWFkcy8ke3RoaXMuYnJhbmNofWApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6dXBkYXRlZFJlZiB9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9yZWZzL3tyZWZ9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBzaGEsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRSZWYub2JqZWN0LnNoYVxuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2IoZmlsZV9zaGE6c3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBibG9iIH0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9icy97ZmlsZV9zaGF9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICBmaWxlX3NoYSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYmxvYi5jb250ZW50XG4gICAgfVxufSIsICJpbXBvcnQgeyBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IEZpdCB9IGZyb20gXCIuL2ZpdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXROb3RpY2Uge1xuICAgIGZpdDogRml0XG4gICAgbXV0ZWQ6IGJvb2xlYW5cbiAgICBub3RpY2U6IG51bGwgfCBOb3RpY2VcbiAgICBjbGFzc2VzOiBBcnJheTxzdHJpbmc+XG5cblx0Y29uc3RydWN0b3IoZml0OiBGaXQsIGFkZENsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSwgaW5pdGlhbE1lc3NhZ2U/OiBzdHJpbmcsIGR1cmF0aW9uID0gMCwgbXV0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZpdCA9IGZpdFxuICAgICAgICB0aGlzLm11dGVkID0gbXV0ZWRcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gWydmaXQtbm90aWNlJ11cbiAgICAgICAgaWYgKGluaXRpYWxNZXNzYWdlICYmICF0aGlzLm11dGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coaW5pdGlhbE1lc3NhZ2UsIGFkZENsYXNzZXMsIGR1cmF0aW9uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gWy4uLnRoaXMuY2xhc3NlcywgLi4uYWRkQ2xhc3Nlc11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11dGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubXV0ZWQgPSB0cnVlXG4gICAgICAgIGlmICh0aGlzLm5vdGljZSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpY2UuaGlkZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bm11dGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubXV0ZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIHNob3coaW5pdGlhbE1lc3NhZ2U/OiBzdHJpbmcsIGFkZENsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSwgZHVyYXRpb24gPSAwKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5ub3RpY2UgJiYgIXRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoaW5pdGlhbE1lc3NhZ2UgJiYgaW5pdGlhbE1lc3NhZ2UubGVuZ3RoID4gMCk/IGluaXRpYWxNZXNzYWdlIDogXCIgXCJcbiAgICAgICAgICAgIHRoaXMubm90aWNlID0gbmV3IE5vdGljZShtZXNzYWdlLCBkdXJhdGlvbilcbiAgICAgICAgICAgIHRoaXMubm90aWNlLm5vdGljZUVsLmFkZENsYXNzZXMoWy4uLnRoaXMuY2xhc3NlcywgLi4uYWRkQ2xhc3Nlc10pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDbGFzc2VzKGFkZENsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSwgcmVtb3ZlQ2xhc3NlczogQXJyYXk8c3RyaW5nPiA9IFtdKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm11dGVkKSB7cmV0dXJufVxuICAgICAgICB0aGlzLmNsYXNzZXMgPSB0aGlzLmNsYXNzZXMuZmlsdGVyKGMgPT4gIXJlbW92ZUNsYXNzZXMuaW5jbHVkZXMoYykpXG4gICAgICAgIGlmICh0aGlzLm5vdGljZSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpY2Uubm90aWNlRWwucmVtb3ZlQ2xhc3NlcyhyZW1vdmVDbGFzc2VzKVxuICAgICAgICAgICAgdGhpcy5ub3RpY2Uubm90aWNlRWwuYWRkQ2xhc3NlcyhhZGRDbGFzc2VzKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFsuLi50aGlzLmNsYXNzZXMsIC4uLmFkZENsYXNzZXNdXG4gICAgfVxuXG4gICAgLy8gYWxsb3dzIGVycm9yIGRpc3BsYXkgdG8gb3ZlcnJpZGUgbXV0ZWRcbiAgICBzZXRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZywgaXNFcnJvcj86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub3RpY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZSA9IG5ldyBOb3RpY2UobWVzc2FnZSwgMClcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZS5ub3RpY2VFbC5hZGRDbGFzc2VzKFsnZml0LW5vdGljZScsICdlcnJvciddKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZS5zZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub3RpY2UgJiYgIXRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZS5zZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmUoZmluYWxDbGFzcz86IHN0cmluZywgZHVyYXRpb24gPSA1MDAwKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm11dGVkKSB7cmV0dXJufVxuXHRcdHRoaXMubm90aWNlPy5ub3RpY2VFbC5yZW1vdmVDbGFzc2VzKHRoaXMuY2xhc3Nlcy5maWx0ZXIoYyA9PiBjICE9PSBcImZpdC1ub3RpY2VcIikpXG4gICAgICAgIGlmIChmaW5hbENsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGljZT8ubm90aWNlRWwuYWRkQ2xhc3MoZmluYWxDbGFzcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm90aWNlPy5ub3RpY2VFbC5hZGRDbGFzcyhcImRvbmVcIilcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubm90aWNlPy5oaWRlKCksIGR1cmF0aW9uKVxuICAgIH1cblxufSIsICJpbXBvcnQgRml0UGx1Z2luIGZyb20gXCJtYWluXCI7XG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHNldEVxdWFsIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IHdhcm4gfSBmcm9tIFwiY29uc29sZVwiO1xuXG50eXBlIFJlZnJlc2hDaGVja1BvaW50ID0gXCJyZXBvKDApXCIgfCBcImJyYW5jaCgxKVwiIHwgXCJsaW5rKDIpXCIgfCBcImluaXRpYWxpemVcIiB8IFwid2l0aENhY2hlXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml0U2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IEZpdFBsdWdpbjtcblx0YXV0aGVudGljYXRpbmc6IGJvb2xlYW47XG5cdGF1dGhVc2VyQXZhdGFyOiBIVE1MRGl2RWxlbWVudDtcblx0YXV0aFVzZXJIYW5kbGU6IEhUTUxTcGFuRWxlbWVudDtcblx0cGF0U2V0dGluZzogU2V0dGluZ1xuXHRvd25lclNldHRpbmc6IFNldHRpbmdcblx0cmVwb1NldHRpbmc6IFNldHRpbmdcblx0YnJhbmNoU2V0dGluZzogU2V0dGluZ1xuXHRleGlzdGluZ1JlcG9zOiBBcnJheTxzdHJpbmc+O1xuXHRleGlzdGluZ0JyYW5jaGVzOiBBcnJheTxzdHJpbmc+O1xuXHRyZXBvTGluazogc3RyaW5nO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEZpdFBsdWdpbikge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0XHR0aGlzLnJlcG9MaW5rID0gdGhpcy5nZXRMYXRlc3RMaW5rKCk7XG5cdFx0dGhpcy5hdXRoZW50aWNhdGluZyA9IGZhbHNlXG5cdFx0dGhpcy5leGlzdGluZ1JlcG9zID0gW11cblx0XHR0aGlzLmV4aXN0aW5nQnJhbmNoZXMgPSBbXVxuXHR9XG5cblx0Z2V0TGF0ZXN0TGluayA9ICgpOiBzdHJpbmcgPT4ge1xuXHRcdGNvbnN0IHtvd25lciwgcmVwbywgYnJhbmNofSA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuXHRcdGlmIChvd25lci5sZW5ndGggPiAwICYmIHJlcG8ubGVuZ3RoID4gMCAmJiBicmFuY2gubGVuZ3RoID4gMCkge1xuXHRcdFx0cmV0dXJuIGBodHRwczovL2dpdGh1Yi5jb20vJHtvd25lcn0vJHtyZXBvfS90cmVlLyR7YnJhbmNofWBcblx0XHR9XG5cdFx0cmV0dXJuIFwiXCJcblx0fVxuXG5cdGhhbmRsZVVzZXJGZXRjaCA9IGFzeW5jICgpID0+IHtcblx0XHR0aGlzLmF1dGhlbnRpY2F0aW5nID0gdHJ1ZVxuXHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIucmVtb3ZlQ2xhc3MoJ2Vycm9yJylcblx0XHR0aGlzLmF1dGhVc2VyQXZhdGFyLmVtcHR5KClcblx0XHR0aGlzLmF1dGhVc2VyQXZhdGFyLnJlbW92ZUNsYXNzKCdlbXB0eScpXG5cdFx0dGhpcy5hdXRoVXNlckF2YXRhci5hZGRDbGFzcygnY2F0Jylcblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qge293bmVyLCBhdmF0YXJVcmx9ID0gYXdhaXQgdGhpcy5wbHVnaW4uZml0LmdldFVzZXIoKTtcblx0XHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIucmVtb3ZlQ2xhc3MoJ2NhdCcpXG5cdFx0XHR0aGlzLmF1dGhVc2VyQXZhdGFyLmNyZWF0ZUVsKCdpbWcnLCB7IGF0dHI6IHsgc3JjOiBhdmF0YXJVcmwgfSB9KTtcblx0XHRcdHRoaXMuYXV0aFVzZXJIYW5kbGUuc2V0VGV4dChvd25lcilcblx0XHRcdGlmIChvd25lciAhPT0gdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3duZXIpIHtcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3Mub3duZXIgPSBvd25lclxuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdmF0YXJVcmwgPSBhdmF0YXJVcmxcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwbyA9IFwiXCJcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoID0gXCJcIlxuXHRcdFx0XHR0aGlzLmV4aXN0aW5nQnJhbmNoZXMgPSBbXVxuXHRcdFx0XHR0aGlzLmV4aXN0aW5nUmVwb3MgPSBbXVxuXHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWZyZXNoRmllbGRzKCdyZXBvKDApJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmF1dGhlbnRpY2F0aW5nID0gZmFsc2Vcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5hdXRoVXNlckF2YXRhci5yZW1vdmVDbGFzcygnY2F0Jylcblx0XHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIuYWRkQ2xhc3MoJ2Vycm9yJylcblx0XHRcdHRoaXMuYXV0aFVzZXJIYW5kbGUuc2V0VGV4dChcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgbWFrZSBzdXJlIHlvdXIgdG9rZW4gaGFzIG5vdCBleHBpcmVkLlwiKVxuXHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3Mub3duZXIgPSBcIlwiXG5cdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdmF0YXJVcmwgPSBcIlwiXG5cdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvID0gXCJcIlxuXHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoID0gXCJcIlxuXHRcdFx0dGhpcy5leGlzdGluZ0JyYW5jaGVzID0gW11cblx0XHRcdHRoaXMuZXhpc3RpbmdSZXBvcyA9IFtdXG5cdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdHRoaXMucmVmcmVzaEZpZWxkcygnaW5pdGlhbGl6ZScpO1xuXHRcdFx0dGhpcy5hdXRoZW50aWNhdGluZyA9IGZhbHNlXG5cdFx0fVxuXHR9XG5cblx0Z2l0aHViVXNlckluZm9CbG9jayA9ICgpID0+IHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpc1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKClcblx0XHQuc2V0TmFtZShcIkdpdEh1YiB1c2VyIGluZm9cIilcblx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0LnNldEJ1dHRvblRleHQoXCJBdXRoZW50aWNhdGUgdXNlclwiKVxuXHRcdFx0LnNldERpc2FibGVkKHRoaXMuYXV0aGVudGljYXRpbmcpXG5cdFx0XHQub25DbGljayhhc3luYyAoKT0+e1xuXHRcdFx0XHRpZiAodGhpcy5hdXRoZW50aWNhdGluZykgcmV0dXJuXG5cdFx0XHRcdGF3YWl0IHRoaXMuaGFuZGxlVXNlckZldGNoKClcblx0XHRcdH0pKVxuXHRcdHRoaXMub3duZXJTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0RGVzYyhcIklucHV0IHlvdXIgcGVyc29uYWwgYWNjZXNzIHRva2VuIGJlbG93IHRvIGdldCBhdXRoZW50aWNhdGVkLiBDcmVhdGUgYSBHaXRIdWIgYWNjb3VudCBoZXJlIGlmIHlvdSBkb24ndCBoYXZlIG9uZSB5ZXQuXCIpXG5cdFx0XHQuYWRkRXh0cmFCdXR0b24oYnV0dG9uPT5idXR0b25cblx0XHRcdFx0LnNldEljb24oJ2dpdGh1YicpXG5cdFx0XHRcdC5zZXRUb29sdGlwKFwiU2lnbiB1cCBvbiBnaXRodWIuY29tXCIpXG5cdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpPT57XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oXCJodHRwczovL2dpdGh1Yi5jb20vc2lnbnVwXCIsIFwiX2JsYW5rXCIpXG5cdFx0XHRcdH0pKVxuXHRcdHRoaXMub3duZXJTZXR0aW5nLm5hbWVFbC5hZGRDbGFzcygnZml0LWF2YXRhci1jb250YWluZXInKTtcblx0XHRpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3duZXIgPT09IFwiXCIpIHtcblx0XHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIgPSB0aGlzLm93bmVyU2V0dGluZy5uYW1lRWwuY3JlYXRlRGl2KFxuXHRcdFx0XHR7Y2xzOiAnZml0LWF2YXRhci1jb250YWluZXIgZW1wdHknfSlcblx0XHRcdHRoaXMuYXV0aFVzZXJIYW5kbGUgPSB0aGlzLm93bmVyU2V0dGluZy5uYW1lRWwuY3JlYXRlRWwoJ3NwYW4nLCB7Y2xzOiAnZml0LWdpdGh1Yi1oYW5kbGUnfSlcblx0XHRcdHRoaXMuYXV0aFVzZXJIYW5kbGUuc2V0VGV4dChcIlVuYXV0aGVudGljYXRlZFwiKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmF1dGhVc2VyQXZhdGFyID0gdGhpcy5vd25lclNldHRpbmcubmFtZUVsLmNyZWF0ZURpdihcblx0XHRcdFx0e2NsczogJ2ZpdC1hdmF0YXItY29udGFpbmVyJ30pXG5cdFx0XHR0aGlzLmF1dGhVc2VyQXZhdGFyLmNyZWF0ZUVsKCdpbWcnLCB7IGF0dHI6IHsgc3JjOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdmF0YXJVcmwgfSB9KTtcblx0XHRcdHRoaXMuYXV0aFVzZXJIYW5kbGUgPSB0aGlzLm93bmVyU2V0dGluZy5uYW1lRWwuY3JlYXRlRWwoJ3NwYW4nLCB7Y2xzOiAnZml0LWdpdGh1Yi1oYW5kbGUnfSlcblx0XHRcdHRoaXMuYXV0aFVzZXJIYW5kbGUuc2V0VGV4dCh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lcilcblx0XHR9XG5cdFx0Ly8gaGlkZSB0aGUgY29udHJvbCBlbGVtZW50IHRvIG1ha2Ugc3BhY2UgZm9yIGF1dGhVc2VyXG5cdFx0dGhpcy5vd25lclNldHRpbmcuY29udHJvbEVsLmFkZENsYXNzKCdmaXQtYXZhdGFyLWRpc3BsYXktdGV4dCcpO1xuXG5cdFx0dGhpcy5wYXRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnR2l0aHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbicpXG5cdFx0XHQuc2V0RGVzYygnUmVtZW1iZXIgdG8gZ2l2ZSBpdCBhY2Nlc3MgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIHN0b3JhZ2UgcmVwby4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignR2l0SHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbicpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXQpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXQgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpXG5cdFx0XHQuYWRkRXh0cmFCdXR0b24oYnV0dG9uPT5idXR0b25cblx0XHRcdFx0LnNldEljb24oJ2V4dGVybmFsLWxpbmsnKVxuXHRcdFx0XHQuc2V0VG9vbHRpcChcIkNyZWF0ZSBhIHRva2VuXCIpXG5cdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpPT57XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oXCJodHRwczovL2dpdGh1Yi5jb20vc2V0dGluZ3MvdG9rZW5zL25ld1wiLCAnX2JsYW5rJyk7XG5cdFx0XHRcdH0pKVxuXHR9XG5cblx0cmVwb0luZm9CbG9jayA9IGFzeW5jICgpID0+IHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpc1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKCkuc2V0TmFtZShcIlJlcG9zaXRvcnkgaW5mb1wiKVxuXHRcdC5zZXREZXNjKFwiUmVmcmVzaCB0byByZXRyaWV2ZSB0aGUgbGF0ZXN0IGxpc3Qgb2YgcmVwb3MgYW5kIGJyYW5jaGVzLlwiKVxuXHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHQuc2V0VG9vbHRpcChcIlJlZnJlc2ggcmVwb3MgYW5kIGJyYW5jaGVzIGxpc3RcIilcblx0XHRcdC5zZXREaXNhYmxlZCh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lciA9PT0gXCJcIilcblx0XHRcdC5zZXRJY29uKCdyZWZyZXNoLWN3Jylcblx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWZyZXNoRmllbGRzKCdyZXBvKDApJyk7XG5cdFx0XHR9KSlcblx0XHRcdFxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldERlc2MoXCJTZWxlY3QgJ0FkZCBhIFJFQURNRSBmaWxlJyBpZiBjcmVhdGluZyBhIG5ldyByZXBvLiBNYWtlIHN1cmUgeW91IGFyZSBsb2dnZWQgaW4gdG8gZ2l0aHViIG9uIHlvdXIgYnJvd3Nlci5cIilcblx0XHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRJY29uKCdnaXRodWInKVxuXHRcdFx0XHQuc2V0VG9vbHRpcChcIkNyZWF0ZSBhIG5ldyByZXBvc2l0b3J5XCIpXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHR3aW5kb3cub3BlbihgaHR0cHM6Ly9naXRodWIuY29tL25ld2AsICdfYmxhbmsnKTtcblx0XHRcdFx0fSkpXG5cdFx0XHRcdFxuXHRcdHRoaXMucmVwb1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdHaXRodWIgcmVwb3NpdG9yeSBuYW1lJylcblx0XHRcdC5zZXREZXNjKFwiU2VsZWN0IGEgcmVwbyB0byBzeW5jIHlvdXIgdmF1bHQuXCIpXG5cdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuXHRcdFx0XHRkcm9wZG93bi5zZWxlY3RFbC5hZGRDbGFzcygncmVwby1kcm9wZG93bicpO1xuXHRcdFx0XHR0aGlzLmV4aXN0aW5nUmVwb3MubWFwKHJlcG89PmRyb3Bkb3duLmFkZE9wdGlvbihyZXBvLCByZXBvKSlcblx0XHRcdFx0ZHJvcGRvd24uc2V0RGlzYWJsZWQodGhpcy5leGlzdGluZ1JlcG9zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0ZHJvcGRvd24uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwbylcblx0XHRcdFx0ZHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwb0NoYW5nZWQgPSB2YWx1ZSAhPT0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwb1xuXHRcdFx0XHRcdGlmIChyZXBvQ2hhbmdlZCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwbyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlZnJlc2hGaWVsZHMoJ2JyYW5jaCgxKScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH0pXG5cblx0XHR0aGlzLmJyYW5jaFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdCcmFuY2ggbmFtZScpXG5cdFx0XHQuc2V0RGVzYygnU2VsZWN0IGEgcmVwbyBhYm92ZSB0byB2aWV3IGV4aXN0aW5nIGJyYW5jaGVzLicpXG5cdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuXHRcdFx0XHRkcm9wZG93bi5zZWxlY3RFbC5hZGRDbGFzcygnYnJhbmNoLWRyb3Bkb3duJyk7XG5cdFx0XHRcdGRyb3Bkb3duLnNldERpc2FibGVkKHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5tYXAocmVwbz0+ZHJvcGRvd24uYWRkT3B0aW9uKHJlcG8sIHJlcG8pKVxuXHRcdFx0XHRkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2gpXG5cdFx0XHRcdGRyb3Bkb3duLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGJyYW5jaENoYW5nZWQgPSB2YWx1ZSAhPT0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoXG5cdFx0XHRcdFx0aWYgKGJyYW5jaENoYW5nZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlZnJlc2hGaWVsZHMoJ2xpbmsoMiknKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9KVxuXG5cdFx0dGhpcy5yZXBvTGluayA9IHRoaXMuZ2V0TGF0ZXN0TGluaygpXG5cdFx0Y29uc3QgbGlua0Rpc3BsYXkgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiVmlldyB5b3VyIHZhdWx0IG9uIEdpdEh1YlwiKVxuXHRcdFx0LnNldERlc2ModGhpcy5yZXBvTGluaylcblx0XHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXREaXNhYmxlZCh0aGlzLnJlcG9MaW5rLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0LnNldFRvb2x0aXAoXCJPcGVuIG9uIEdpdEh1YlwiKVxuXHRcdFx0XHQuc2V0SWNvbignZXh0ZXJuYWwtbGluaycpXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgb3BlbmluZyAke3RoaXMucmVwb0xpbmt9YClcblx0XHRcdFx0XHR3aW5kb3cub3Blbih0aGlzLnJlcG9MaW5rLCAnX2JsYW5rJyk7XG5cdFx0XHRcdH0pXG5cdFx0XHQpXG5cdFx0bGlua0Rpc3BsYXkuZGVzY0VsLmFkZENsYXNzKFwibGluay1kZXNjXCIpXG5cdH1cblxuXHRsb2NhbENvbmZpZ0Jsb2NrID0gKCkgPT4ge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiTG9jYWwgY29uZmlndXJhdGlvbnNcIik7XHRcdFxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0RldmljZSBuYW1lJylcblx0XHRcdC5zZXREZXNjKCdTaWduIGNvbW1pdCBtZXNzYWdlIHdpdGggdGhpcyBkZXZpY2UgbmFtZS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRGV2aWNlIG5hbWUnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGV2aWNlTmFtZSlcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmRldmljZU5hbWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdFxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdC5zZXROYW1lKFwiQXV0byBzeW5jXCIpXG5cdFx0LnNldERlc2MoYEF1dG9tYXRpY2FsbHkgc3luYyB5b3VyIHZhdWx0IHdoZW4gcmVtb3RlIGhhcyB1cGRhdGVzLiAoTXV0ZWQ6IHN5bmMgaW4gdGhlIGJhY2tncm91bmQgd2l0aG91dCBkaXNwbGF5aW5nIG5vdGljZXMsIGV4Y2VwdCBmb3IgZmlsZSBjaGFuZ2VzIGFuZCBjb25mbGljdHMgbm90aWNlKWApXG5cdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcblx0XHRcdGRyb3Bkb3duXG5cdFx0XHQuYWRkT3B0aW9uKCdvZmYnLCAnT2ZmJylcblx0XHRcdC5hZGRPcHRpb24oJ211dGVkJywgJ011dGVkJylcblx0XHRcdC5hZGRPcHRpb24oJ3JlbWluZCcsICdSZW1pbmQgb25seScpXG5cdFx0XHQuYWRkT3B0aW9uKCdvbicsICdPbicpXG5cdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b1N5bmMgPyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvU3luYyA6ICdvZmYnKVxuXHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvU3luYyA9IHZhbHVlIGFzIFwib2ZmXCIgfCBcIm11dGVkXCIgfCBcInJlbWluZFwiIHwgXCJvblwiO1xuXHRcdFx0XHRjaGVja0ludGVydmFsU2xpZGVyLnNldHRpbmdFbC5hZGRDbGFzcyh2YWx1ZSA9PT0gXCJvZmZcIiA/IFwiY2xlYXJcIiA6IFwicmVzdG9yZVwiKTtcblx0XHRcdFx0Y2hlY2tJbnRlcnZhbFNsaWRlci5zZXR0aW5nRWwucmVtb3ZlQ2xhc3ModmFsdWUgPT09IFwib2ZmXCIgPyBcInJlc3RvcmVcIiA6IFwiY2xlYXJcIik7XG5cdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0fSlcblx0XHR9KVxuXHRcdFxuXHRcdGNvbnN0IGNoZWNrSW50ZXJ2YWxTbGlkZXIgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdBdXRvIGNoZWNrIGludGVydmFsJylcblx0XHRcdC5zZXREZXNjKGBBdXRvbWF0aWNhbGx5IGNoZWNrIGZvciByZW1vdGUgY2hhbmdlcyBpbiB0aGUgYmFja2dyb3VuZCBldmVyeSAke3RoaXMucGx1Z2luLnNldHRpbmdzLmNoZWNrRXZlcnlYTWludXRlc30gbWludXRlcy5gKVxuXHRcdFx0LmFkZFNsaWRlcihzbGlkZXIgPT4gc2xpZGVyXG5cdFx0XHRcdC5zZXRMaW1pdHMoMSwgNjAsIDEpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jaGVja0V2ZXJ5WE1pbnV0ZXMpXG5cdFx0XHRcdC5zZXREeW5hbWljVG9vbHRpcCgpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5jaGVja0V2ZXJ5WE1pbnV0ZXMgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRjaGVja0ludGVydmFsU2xpZGVyLnNldERlc2MoYEF1dG9tYXRpY2FsbHkgY2hlY2sgZm9yIHJlbW90ZSBjaGFuZ2VzIGluIHRoZSBiYWNrZ3JvdW5kIGV2ZXJ5ICR7dmFsdWV9IG1pbnV0ZXMuYClcblx0XHRcdFx0fSlcblx0XHRcdClcblxuXHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvU3luYyA9PT0gXCJvZmZcIikge1xuXHRcdFx0Y2hlY2tJbnRlcnZhbFNsaWRlci5zZXR0aW5nRWwuYWRkQ2xhc3MoXCJjbGVhclwiKVxuXHRcdH1cblx0fVxuXG5cdG5vdGljZUNvbmZpZ0Jsb2NrID0gKCkgPT4ge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzXG5cdFx0Y29uc3Qgc2VsZWN0ZWRDb2wgPSBcInZhcigtLWludGVyYWN0aXZlLWFjY2VudClcIlxuXHRcdGNvbnN0IHNlbGVjdGVkVHh0Q29sID0gXCJ2YXIoLS10ZXh0LW9uLWFjY2VudClcIlxuXHRcdGNvbnN0IHVuc2VsZWN0ZWRDb2xvciA9IFwidmFyKC0taW50ZXJhY3RpdmUtbm9ybWFsKVwiXG5cdFx0Y29uc3QgdW5zZWxlY3RlZFR4dENvbCA9IFwidmFyKC0tdGV4dC1ub3JtYWwpXCJcblx0XHRjb25zdCBzdGF0ZVRleHRNYXAgPSAobm90aWZ5Q29uZmxpY3RzOiBib29sZWFuLCBub3RpZnlDaGFuZ2VzOiBib29sZWFuKSA9PiB7XG5cdFx0XHRpZiAobm90aWZ5Q29uZmxpY3RzICYmIG5vdGlmeUNoYW5nZXMpIHtcblx0XHRcdFx0cmV0dXJuIFwiRGlzcGxheWluZyBmaWxlIGNoYW5nZXMgYW5kIGNvbmZsaWN0cyBcIlxuXHRcdFx0fSBlbHNlIGlmICghbm90aWZ5Q29uZmxpY3RzICYmIG5vdGlmeUNoYW5nZXMpIHtcblx0XHRcdFx0cmV0dXJuIFwiRGlzcGxheWluZyBmaWxlIGNoYW5nZXMgXCJcblx0XHRcdH0gZWxzZSBpZiAobm90aWZ5Q29uZmxpY3RzICYmICFub3RpZnlDaGFuZ2VzKSB7XG5cdFx0XHRcdHJldHVybiBcIkRpc3BsYXlpbmcgY2hhbmdlIGNvbmZsaWN0cyBcIlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIFwiTm8gbm90aWNlIGRpc3BsYXllZCBcIlxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBub3RpY2VEaXNwbGF5ID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIk5vdGljZSBkaXNwbGF5XCIpXG5cdFx0XHQuc2V0RGVzYyhgJHtzdGF0ZVRleHRNYXAodGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90aWZ5Q29uZmxpY3RzLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZnlDaGFuZ2VzKX0gYWZ0ZXIgc3luYy5gKVxuXG5cdFx0bm90aWNlRGlzcGxheS5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiQ2hhbmdlIGNvbmZsaWN0c1wiKVxuXHRcdFx0YnV0dG9uLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBub3RpZnlDb25mbGljdHMgPSAhdGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90aWZ5Q29uZmxpY3RzO1xuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZnlDb25mbGljdHMgPSBub3RpZnlDb25mbGljdHNcblx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdGJ1dHRvbi5idXR0b25FbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0XHRcdFwiYmFja2dyb3VuZFwiOiBub3RpZnlDb25mbGljdHMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcblx0XHRcdFx0XHRcImNvbG9yXCI6IG5vdGlmeUNvbmZsaWN0cyA/IHNlbGVjdGVkVHh0Q29sIDogdW5zZWxlY3RlZFR4dENvbCxcblx0XHRcdFx0fSlcblx0XHRcdFx0bm90aWNlRGlzcGxheS5zZXREZXNjKGAke3N0YXRlVGV4dE1hcChub3RpZnlDb25mbGljdHMsIHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGlmeUNoYW5nZXMpfSBhZnRlciBzeW5jLmApXG5cdFx0XHR9KVxuXHRcdFx0YnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG5cdFx0XHRcdFwiYmFja2dyb3VuZFwiOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZnlDb25mbGljdHMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcblx0XHRcdFx0XCJjb2xvclwiOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZnlDb25mbGljdHMgPyBzZWxlY3RlZFR4dENvbCA6IHVuc2VsZWN0ZWRUeHRDb2wsXG5cdFx0XHR9KVxuXHRcdH0pXG5cdFx0bm90aWNlRGlzcGxheS5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiRmlsZSBjaGFuZ2VzXCIpXG5cdFx0XHRidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IG5vdGlmeUNoYW5nZXMgPSAhdGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90aWZ5Q2hhbmdlcztcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3Mubm90aWZ5Q2hhbmdlcyA9IG5vdGlmeUNoYW5nZXNcblx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdGJ1dHRvbi5idXR0b25FbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0XHRcdFwiYmFja2dyb3VuZFwiOiBub3RpZnlDaGFuZ2VzID8gc2VsZWN0ZWRDb2wgOiB1bnNlbGVjdGVkQ29sb3IsXG5cdFx0XHRcdFx0XCJjb2xvclwiOiBub3RpZnlDaGFuZ2VzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuXHRcdFx0XHR9KVxuXHRcdFx0XHRub3RpY2VEaXNwbGF5LnNldERlc2MoYCR7c3RhdGVUZXh0TWFwKHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGlmeUNvbmZsaWN0cywgbm90aWZ5Q2hhbmdlcyl9IGFmdGVyIHN5bmMuYClcblx0XHRcdH0pXG5cdFx0XHRidXR0b24uYnV0dG9uRWwuc2V0Q3NzU3R5bGVzKHtcblx0XHRcdFx0XCJiYWNrZ3JvdW5kXCI6IHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGlmeUNoYW5nZXMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcblx0XHRcdFx0XCJjb2xvclwiOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZnlDaGFuZ2VzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuXHRcdFx0fSlcblx0XHR9KVxuXHR9XG5cblx0cmVmcmVzaEZpZWxkcyA9IGFzeW5jIChyZWZyZXNoRnJvbTogUmVmcmVzaENoZWNrUG9pbnQpID0+IHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpc1xuXHRcdGNvbnN0IHJlcG9fZHJvcGRvd24gPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcucmVwby1kcm9wZG93bicpIGFzIEhUTUxTZWxlY3RFbGVtZW50XG5cdFx0Y29uc3QgYnJhbmNoX2Ryb3Bkb3duID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignLmJyYW5jaC1kcm9wZG93bicpIGFzIEhUTUxTZWxlY3RFbGVtZW50XG5cdFx0Y29uc3QgbGlua19lbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5saW5rLWRlc2MnKSBhcyBIVE1MRWxlbWVudFxuXHRcdGlmIChyZWZyZXNoRnJvbSA9PT0gXCJyZXBvKDApXCIpIHtcblx0XHRcdHJlcG9fZHJvcGRvd24uZGlzYWJsZWQgPSB0cnVlXG5cdFx0XHRicmFuY2hfZHJvcGRvd24uZGlzYWJsZWQgPSB0cnVlXG5cdFx0XHR0aGlzLmV4aXN0aW5nUmVwb3MgPSBhd2FpdCB0aGlzLnBsdWdpbi5maXQuZ2V0UmVwb3MoKTtcblx0XHRcdGNvbnN0IHJlcG9PcHRpb25zID0gQXJyYXkuZnJvbShyZXBvX2Ryb3Bkb3duLm9wdGlvbnMpLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcblx0XHRcdGlmICghc2V0RXF1YWw8c3RyaW5nPih0aGlzLmV4aXN0aW5nUmVwb3MsIHJlcG9PcHRpb25zKSkge1xuXHRcdFx0XHRyZXBvX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdFx0dGhpcy5leGlzdGluZ1JlcG9zLm1hcChyZXBvID0+IHtcblx0XHRcdFx0XHRyZXBvX2Ryb3Bkb3duLmFkZChuZXcgT3B0aW9uKHJlcG8sIHJlcG8pKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gaWYgb3JpZ2luYWwgcmVwbyBub3QgaW4gdGhlIHVwZGF0ZWQgZXhpc3RpbmcgcmVwbywgLTEgd2lsbCBiZSByZXR1cm5lZFxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZFJlcG9JbmRleCA9IHRoaXMuZXhpc3RpbmdSZXBvcy5pbmRleE9mKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlcG8pO1xuXHRcdFx0XHQvLyBzZXR0aW5nIHNlbGVjdGVkSW5kZXggdG8gLTEgdG8gaW5kaWNhdGUgbm8gb3B0aW9ucyBzZWxlY3RlZFxuXHRcdFx0XHRyZXBvX2Ryb3Bkb3duLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZFJlcG9JbmRleCBcblx0XHRcdFx0aWYgKHNlbGVjdGVkUmVwb0luZGV4PT09LTEpe1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJlcG8gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlcG9fZHJvcGRvd24uZGlzYWJsZWQgPSBmYWxzZVxuXHRcdH1cblx0XHRpZiAocmVmcmVzaEZyb20gPT09IFwiYnJhbmNoKDEpXCIgfHwgcmVmcmVzaEZyb20gPT09IFwicmVwbygwKVwiKSB7XG5cdFx0XHRpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwbyA9PT0gXCJcIikge1xuXHRcdFx0XHRicmFuY2hfZHJvcGRvd24uZW1wdHkoKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbGF0ZXN0QnJhbmNoZXMgPSBhd2FpdCB0aGlzLnBsdWdpbi5maXQuZ2V0QnJhbmNoZXMoKTtcblx0XHRcdFx0aWYgKCFzZXRFcXVhbDxzdHJpbmc+KHRoaXMuZXhpc3RpbmdCcmFuY2hlcywgbGF0ZXN0QnJhbmNoZXMpKSB7XG5cdFx0XHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdFx0XHR0aGlzLmV4aXN0aW5nQnJhbmNoZXMgPSBsYXRlc3RCcmFuY2hlc1xuXHRcdFx0XHRcdHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5tYXAoYnJhbmNoID0+IHtcblx0XHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5hZGQobmV3IE9wdGlvbihicmFuY2gsIGJyYW5jaCkpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gaWYgb3JpZ2luYWwgYnJhbmNoIG5vdCBpbiB0aGUgdXBkYXRlZCBleGlzdGluZyBicmFuY2gsIC0xIHdpbGwgYmUgcmV0dXJuZWRcblx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZEJyYW5jaEluZGV4ID0gdGhpcy5leGlzdGluZ0JyYW5jaGVzLmluZGV4T2YodGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoKTtcblx0XHRcdFx0XHQvLyBzZXR0aW5nIHNlbGVjdGVkSW5kZXggdG8gLTEgdG8gaW5kaWNhdGUgbm8gb3B0aW9ucyBzZWxlY3RlZFxuXHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRCcmFuY2hJbmRleFxuXHRcdFx0XHRcdGlmIChzZWxlY3RlZEJyYW5jaEluZGV4PT09LTEpe1xuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoID0gXCJcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmRpc2FibGVkID0gZmFsc2Vcblx0XHR9IFxuXHRcdGlmIChyZWZyZXNoRnJvbSA9PT0gXCJsaW5rKDIpXCIgfHwgcmVmcmVzaEZyb20gPT09IFwiYnJhbmNoKDEpXCIgfHwgcmVmcmVzaEZyb20gPT09IFwicmVwbygwKVwiKSB7XG5cdFx0XHR0aGlzLnJlcG9MaW5rID0gdGhpcy5nZXRMYXRlc3RMaW5rKCk7XG5cdFx0XHRsaW5rX2VsLmlubmVyVGV4dCA9IHRoaXMucmVwb0xpbmtcblx0XHR9IFxuXHRcdGlmIChyZWZyZXNoRnJvbSA9PT0gXCJpbml0aWFsaXplXCIpIHtcblx0XHRcdGNvbnN0IHtyZXBvLCBicmFuY2h9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Ncblx0XHRcdHJlcG9fZHJvcGRvd24uZW1wdHkoKVxuXHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdHJlcG9fZHJvcGRvd24uYWRkKG5ldyBPcHRpb24ocmVwbywgcmVwbykpXG5cdFx0XHRicmFuY2hfZHJvcGRvd24uYWRkKG5ldyBPcHRpb24oYnJhbmNoLCBicmFuY2gpKVxuXHRcdFx0bGlua19lbC5pbm5lclRleHQgPSB0aGlzLmdldExhdGVzdExpbmsoKVxuXHRcdH1cblx0XHRpZiAocmVmcmVzaEZyb20gPT09IFwid2l0aENhY2hlXCIpIHtcblx0XHRcdHJlcG9fZHJvcGRvd24uZW1wdHkoKVxuXHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdGlmICh0aGlzLmV4aXN0aW5nUmVwb3MubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLmV4aXN0aW5nUmVwb3MubWFwKHJlcG8gPT4ge1xuXHRcdFx0XHRcdHJlcG9fZHJvcGRvd24uYWRkKG5ldyBPcHRpb24ocmVwbywgcmVwbykpXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXBvX2Ryb3Bkb3duLnNlbGVjdGVkSW5kZXggPSB0aGlzLmV4aXN0aW5nUmVwb3MuaW5kZXhPZih0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5tYXAoYnJhbmNoID0+IHtcblx0XHRcdFx0XHRicmFuY2hfZHJvcGRvd24uYWRkKG5ldyBPcHRpb24oYnJhbmNoLCBicmFuY2gpKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5zZWxlY3RlZEluZGV4ID0gLTFcblx0XHRcdFx0fVxuXHRcdFx0XHRicmFuY2hfZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9IHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5pbmRleE9mKHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaClcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvICE9PSBcIlwiKSB7XG5cdFx0XHRcdGlmICh0aGlzLmV4aXN0aW5nUmVwb3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0cmVwb19kcm9wZG93bi5hZGQobmV3IE9wdGlvbih0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXBvX2Ryb3Bkb3duLnNlbGVjdGVkSW5kZXggPSB0aGlzLmV4aXN0aW5nUmVwb3MuaW5kZXhPZih0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKVxuXHRcdFx0XHRcdGlmIChicmFuY2hfZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHdhcm4oYHdhcm5pbmc6IHNlbGVjdGVkIGJyYW5jaCAke3RoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaH0gbm90IGZvdW5kLCBleGlzdGluZyBicmFuY2hlczogJHt0aGlzLmV4aXN0aW5nQnJhbmNoZXN9YClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2ggIT09IFwiXCIpIHtcblx0XHRcdFx0aWYgKHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRicmFuY2hfZHJvcGRvd24uYWRkKG5ldyBPcHRpb24odGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2gpKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5zZWxlY3RlZEluZGV4ID0gdGhpcy5leGlzdGluZ0JyYW5jaGVzLmluZGV4T2YodGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoKVxuXHRcdFx0XHRcdGlmIChicmFuY2hfZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHdhcm4oYHdhcm5pbmc6IHNlbGVjdGVkIGJyYW5jaCAke3RoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaH0gbm90IGZvdW5kLCBleGlzdGluZyBicmFuY2hlczogJHt0aGlzLmV4aXN0aW5nQnJhbmNoZXN9YClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0dGhpcy5naXRodWJVc2VySW5mb0Jsb2NrKClcblx0XHR0aGlzLnJlcG9JbmZvQmxvY2soKVxuXHRcdHRoaXMubG9jYWxDb25maWdCbG9jaygpXG5cdFx0dGhpcy5ub3RpY2VDb25maWdCbG9jaygpXG5cdFx0dGhpcy5yZWZyZXNoRmllbGRzKFwid2l0aENhY2hlXCIpXG5cdH1cbn0iLCAiaW1wb3J0IHsgYXJyYXlCdWZmZXJUb0Jhc2U2NCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBGaXQgfSBmcm9tIFwiLi9maXRcIlxuaW1wb3J0IHsgQ2xhc2hTdGF0dXMsIENvbmZsaWN0UmVwb3J0LCBDb25mbGljdFJlc29sdXRpb25SZXN1bHQsIEZpbGVPcFJlY29yZCwgTG9jYWxDaGFuZ2UsIExvY2FsVXBkYXRlLCBSZW1vdGVDaGFuZ2UsIFJlbW90ZVVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCJcbmltcG9ydCB7IFJFQ09HTklaRURfQklOQVJZX0VYVCwgZXh0cmFjdEV4dGVuc2lvbiwgcmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nIH0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHsgRml0UHVsbCB9IGZyb20gXCIuL2ZpdFB1bGxcIlxuaW1wb3J0IHsgRml0UHVzaCB9IGZyb20gXCIuL2ZpdFB1c2hcIlxuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSBcIi4vdmF1bHRPcHNcIlxuaW1wb3J0IHsgTG9jYWxTdG9yZXMgfSBmcm9tIFwibWFpblwiXG5pbXBvcnQgRml0Tm90aWNlIGZyb20gXCIuL2ZpdE5vdGljZVwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpdFN5bmMge1xuICAgIGZpdDogRml0XG59XG5cbnR5cGUgUHJlU3luY0NoZWNrUmVzdWx0ID0gIHtcbiAgICBzdGF0dXM6IFwiaW5TeW5jXCJcbn0gfCB7XG4gICAgc3RhdHVzOiBFeGNsdWRlPFByZVN5bmNDaGVja1Jlc3VsdFR5cGUsIFwiaW5TeW5jXCI+XG4gICAgcmVtb3RlVXBkYXRlOiBSZW1vdGVVcGRhdGVcbiAgICBsb2NhbENoYW5nZXM6IExvY2FsQ2hhbmdlW11cbiAgICBsb2NhbFRyZWVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbn1cblxudHlwZSBQcmVTeW5jQ2hlY2tSZXN1bHRUeXBlID0gKFxuICAgIFwiaW5TeW5jXCIgfCBcbiAgICBcIm9ubHlMb2NhbENoYW5nZWRcIiB8IFxuICAgIFwib25seVJlbW90ZUNoYW5nZWRcIiB8IFxuICAgIFwib25seVJlbW90ZUNvbW1pdFNoYUNoYW5nZWRcIiB8XG4gICAgXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDb21wYXRpYmxlXCIgfCBcbiAgICBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NsYXNoZWRcIlxuKVxuXG5leHBvcnQgY2xhc3MgRml0U3luYyBpbXBsZW1lbnRzIElGaXRTeW5jIHtcbiAgICBmaXQ6IEZpdFxuICAgIGZpdFB1bGw6IEZpdFB1bGxcbiAgICBmaXRQdXNoOiBGaXRQdXNoXG4gICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9uc1xuICAgIHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2s6IChsb2NhbFN0b3JlOiBQYXJ0aWFsPExvY2FsU3RvcmVzPikgPT4gUHJvbWlzZTx2b2lkPlxuICAgIFxuXG4gICAgY29uc3RydWN0b3IoZml0OiBGaXQsIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnMsIHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2s6IChsb2NhbFN0b3JlOiBQYXJ0aWFsPExvY2FsU3RvcmVzPikgPT4gUHJvbWlzZTx2b2lkPikge1xuICAgICAgICB0aGlzLmZpdCA9IGZpdFxuICAgICAgICB0aGlzLmZpdFB1bGwgPSBuZXcgRml0UHVsbChmaXQpXG4gICAgICAgIHRoaXMuZml0UHVzaCA9IG5ldyBGaXRQdXNoKGZpdClcbiAgICAgICAgdGhpcy52YXVsdE9wcyA9IHZhdWx0T3BzXG4gICAgICAgIHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayA9IHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2tcbiAgICB9XG5cbiAgICBhc3luYyBwZXJmb3JtUHJlU3luY0NoZWNrcygpOiBQcm9taXNlPFByZVN5bmNDaGVja1Jlc3VsdD4ge1xuICAgICAgICBjb25zdCBjdXJyZW50TG9jYWxTaGEgPSBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICBjb25zdCBsb2NhbENoYW5nZXMgPSBhd2FpdCB0aGlzLmZpdC5nZXRMb2NhbENoYW5nZXMoY3VycmVudExvY2FsU2hhKVxuICAgICAgICBjb25zdCB7cmVtb3RlQ29tbWl0U2hhLCB1cGRhdGVkOiByZW1vdGVVcGRhdGVkfSA9IGF3YWl0IHRoaXMuZml0LnJlbW90ZVVwZGF0ZWQoKTtcbiAgICAgICAgaWYgKGxvY2FsQ2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXJlbW90ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzOiBcImluU3luY1wifVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKHJlbW90ZUNvbW1pdFNoYSlcbiAgICAgICAgY29uc3QgcmVtb3RlQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZUNoYW5nZXMocmVtb3RlVHJlZVNoYSlcbiAgICAgICAgbGV0IGNsYXNoZXM6IENsYXNoU3RhdHVzW10gPSBbXTtcbiAgICAgICAgbGV0IHN0YXR1czogUHJlU3luY0NoZWNrUmVzdWx0VHlwZVxuICAgICAgICBpZiAobG9jYWxDaGFuZ2VzLmxlbmd0aCA+IDAgJiYgIXJlbW90ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IFwib25seUxvY2FsQ2hhbmdlZFwiXG4gICAgICAgIH0gZWxzZSBpZiAocmVtb3RlVXBkYXRlZCAmJiBsb2NhbENoYW5nZXMubGVuZ3RoID09PSAwICYmIHJlbW90ZUNoYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBcIm9ubHlSZW1vdGVDb21taXRTaGFDaGFuZ2VkXCJcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbENoYW5nZXMubGVuZ3RoID09PSAwICYmIHJlbW90ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IFwib25seVJlbW90ZUNoYW5nZWRcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xhc2hlcyA9IHRoaXMuZml0LmdldENsYXNoZWRDaGFuZ2VzKGxvY2FsQ2hhbmdlcywgcmVtb3RlQ2hhbmdlcylcbiAgICAgICAgICAgIGlmIChjbGFzaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwibG9jYWxBbmRSZW1vdGVDaGFuZ2VzQ29tcGF0aWJsZVwiXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NsYXNoZWRcIlxuICAgICAgICAgICAgfSAgICBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzLCBcbiAgICAgICAgICAgIHJlbW90ZVVwZGF0ZToge1xuICAgICAgICAgICAgICAgIHJlbW90ZUNoYW5nZXMsIFxuICAgICAgICAgICAgICAgIHJlbW90ZVRyZWVTaGEsIFxuICAgICAgICAgICAgICAgIGxhdGVzdFJlbW90ZUNvbW1pdFNoYTogcmVtb3RlQ29tbWl0U2hhLCBcbiAgICAgICAgICAgICAgICBjbGFzaGVkRmlsZXM6IGNsYXNoZXNcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgbG9jYWxDaGFuZ2VzLCBcbiAgICAgICAgICAgIGxvY2FsVHJlZVNoYTogY3VycmVudExvY2FsU2hhXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0ZUNvbmZsaWN0UmVwb3J0KHBhdGg6IHN0cmluZywgbG9jYWxDb250ZW50OiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IENvbmZsaWN0UmVwb3J0IHtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRFeHRlbnNpb24gPSBleHRyYWN0RXh0ZW5zaW9uKHBhdGgpXG4gICAgICAgIGlmIChkZXRlY3RlZEV4dGVuc2lvbiAmJiBSRUNPR05JWkVEX0JJTkFSWV9FWFQuaW5jbHVkZXMoZGV0ZWN0ZWRFeHRlbnNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvblN0cmF0ZWd5OiBcImJpbmFyeVwiLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNvbnRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhc3N1bWUgZmlsZSBlbmNvZGluZyBpcyB1dGY4IGlmIGV4dGVuc2lvbiBpcyBub3Qga25vd25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICByZXNvbHV0aW9uU3RyYXRlZ3k6IFwidXRmLThcIixcbiAgICAgICAgICAgIGxvY2FsQ29udGVudCxcbiAgICAgICAgICAgIHJlbW90ZUNvbnRlbnQsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBoYW5kbGVCaW5hcnlDb25mbGljdChwYXRoOiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkPiB7XG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciA9IFwiX2ZpdFwiXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblBhdGggPSBgJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9LyR7cGF0aH1gXG4gICAgICAgIGF3YWl0IHRoaXMuZml0LnZhdWx0T3BzLmVuc3VyZUZvbGRlckV4aXN0cyhjb25mbGljdFJlc29sdXRpb25QYXRoKVxuICAgICAgICBhd2FpdCB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RSZXNvbHV0aW9uUGF0aCwgcmVtb3RlQ29udGVudClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IGNvbmZsaWN0UmVzb2x1dGlvblBhdGgsXG4gICAgICAgICAgICBzdGF0dXM6IFwiY3JlYXRlZFwiXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZVVURjhDb25mbGljdChwYXRoOiBzdHJpbmcsIGxvY2FsQ29udGVudDogc3RyaW5nLCByZW1vdGVDb25lbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkPiB7XG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciA9IFwiX2ZpdFwiXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblBhdGggPSBgJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9LyR7cGF0aH1gXG4gICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLmVuc3VyZUZvbGRlckV4aXN0cyhjb25mbGljdFJlc29sdXRpb25QYXRoKVxuICAgICAgICB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RSZXNvbHV0aW9uUGF0aCwgcmVtb3RlQ29uZW50KVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogY29uZmxpY3RSZXNvbHV0aW9uUGF0aCxcbiAgICAgICAgICAgIHN0YXR1czogXCJjcmVhdGVkXCJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZUxvY2FsRGVsZXRpb25Db25mbGljdChwYXRoOiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkPiB7XG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciA9IFwiX2ZpdFwiXG4gICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLmVuc3VyZUZvbGRlckV4aXN0cyhjb25mbGljdFJlc29sdXRpb25Gb2xkZXIpXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblBhdGggPSBgJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9LyR7cGF0aH1gXG4gICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLndyaXRlVG9Mb2NhbChjb25mbGljdFJlc29sdXRpb25QYXRoLCByZW1vdGVDb250ZW50KVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogY29uZmxpY3RSZXNvbHV0aW9uUGF0aCxcbiAgICAgICAgICAgIHN0YXR1czogXCJjcmVhdGVkXCJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHJlc29sdmVGaWxlQ29uZmxpY3QoY2xhc2g6IENsYXNoU3RhdHVzLCBsYXRlc3RSZW1vdGVGaWxlU2hhOiBzdHJpbmcpOiBQcm9taXNlPENvbmZsaWN0UmVzb2x1dGlvblJlc3VsdD4ge1xuICAgICAgICBpZiAoY2xhc2gubG9jYWxTdGF0dXMgPT09IFwiZGVsZXRlZFwiICYmIGNsYXNoLnJlbW90ZVN0YXR1cyA9PT0gXCJSRU1PVkVEXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7cGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiB0cnVlfVxuICAgICAgICB9IGVsc2UgaWYgKGNsYXNoLmxvY2FsU3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQ29udGVudCA9IGF3YWl0IHRoaXMuZml0LmdldEJsb2IobGF0ZXN0UmVtb3RlRmlsZVNoYSlcbiAgICAgICAgICAgIGNvbnN0IGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlTG9jYWxEZWxldGlvbkNvbmZsaWN0KGNsYXNoLnBhdGgsIHJlbW90ZUNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4ge3BhdGg6IGNsYXNoLnBhdGgsIG5vRGlmZjogZmFsc2UsIGZpbGVPcDogZmlsZU9wfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jYWxGaWxlID0gYXdhaXQgdGhpcy5maXQudmF1bHRPcHMuZ2V0VEZpbGUoY2xhc2gucGF0aClcbiAgICAgICAgY29uc3QgbG9jYWxGaWxlQ29udGVudCA9IGFycmF5QnVmZmVyVG9CYXNlNjQoYXdhaXQgdGhpcy5maXQudmF1bHRPcHMudmF1bHQucmVhZEJpbmFyeShsb2NhbEZpbGUpKVxuICAgICAgICBcbiAgICAgICAgaWYgKGxhdGVzdFJlbW90ZUZpbGVTaGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpdC5nZXRCbG9iKGxhdGVzdFJlbW90ZUZpbGVTaGEpXG4gICAgICAgICAgICBpZiAocmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nKHJlbW90ZUNvbnRlbnQpICE9PSByZW1vdmVMaW5lRW5kaW5nc0Zyb21CYXNlNjRTdHJpbmcobG9jYWxGaWxlQ29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBvcnQgPSB0aGlzLmdlbmVyYXRlQ29uZmxpY3RSZXBvcnQoY2xhc2gucGF0aCwgbG9jYWxGaWxlQ29udGVudCwgcmVtb3RlQ29udGVudClcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU9wOiBGaWxlT3BSZWNvcmRcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0LnJlc29sdXRpb25TdHJhdGVneSA9PT0gXCJiaW5hcnlcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxlT3AgPSBhd2FpdCB0aGlzLmhhbmRsZUJpbmFyeUNvbmZsaWN0KGNsYXNoLnBhdGgsIHJlcG9ydC5yZW1vdGVDb250ZW50KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlVVRGOENvbmZsaWN0KGNsYXNoLnBhdGgsIHJlcG9ydC5sb2NhbENvbnRlbnQsIHJlcG9ydC5yZW1vdGVDb250ZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge3BhdGg6IGNsYXNoLnBhdGgsIG5vRGlmZjogZmFsc2UsIGZpbGVPcDogZmlsZU9wfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiB0cnVlIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFzc3VtZXMgcmVtb3RlIGZpbGUgaXMgZGVsZXRlZCBpZiBzaGEgbm90IGZvdW5kIGluIGxhdGVzdFJlbW90ZVRyZWVTaGEuXG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBjbGFzaC5wYXRoLCBub0RpZmY6IGZhbHNlIH1cbiAgICAgICAgfVxuXHR9XG5cbiAgICBhc3luYyByZXNvbHZlQ29uZmxpY3RzKFxuICAgICAgICBjbGFzaGVkRmlsZXM6IEFycmF5PENsYXNoU3RhdHVzPiwgbGF0ZXN0UmVtb3RlVHJlZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPilcbiAgICAgICAgOiBQcm9taXNlPHtub0NvbmZsaWN0OiBib29sZWFuLCB1bnJlc29sdmVkRmlsZXM6IENsYXNoU3RhdHVzW10sIGZpbGVPcHNSZWNvcmQ6IEZpbGVPcFJlY29yZFtdfT4geyAgICBcbiAgICAgICAgICAgIGNvbnN0IGZpbGVSZXNvbHV0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgIGNsYXNoZWRGaWxlcy5tYXAoY2xhc2g9PntyZXR1cm4gdGhpcy5yZXNvbHZlRmlsZUNvbmZsaWN0KGNsYXNoLCBsYXRlc3RSZW1vdGVUcmVlU2hhW2NsYXNoLnBhdGhdKX0pKVxuICAgICAgICAgICAgY29uc3QgdW5yZXNvbHZlZEZpbGVzID0gZmlsZVJlc29sdXRpb25zLm1hcCgocmVzLCBpKT0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcy5ub0RpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNoZWRGaWxlc1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pIGFzIEFycmF5PENsYXNoU3RhdHVzPlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub0NvbmZsaWN0OiBmaWxlUmVzb2x1dGlvbnMuZXZlcnkocmVzPT5yZXMubm9EaWZmKSwgXG4gICAgICAgICAgICAgICAgdW5yZXNvbHZlZEZpbGVzLFxuICAgICAgICAgICAgICAgIGZpbGVPcHNSZWNvcmQ6IGZpbGVSZXNvbHV0aW9ucy5tYXAociA9PiByLmZpbGVPcCkuZmlsdGVyKEJvb2xlYW4pIGFzIEZpbGVPcFJlY29yZFtdXG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgc3luY0NvbXBhdGlibGVDaGFuZ2VzKFxuICAgICAgICBsb2NhbFVwZGF0ZTogTG9jYWxVcGRhdGUsIFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSwgXG4gICAgICAgIHN5bmNOb3RpY2U6IEZpdE5vdGljZSk6IFByb21pc2U8e2xvY2FsT3BzOiBMb2NhbENoYW5nZVtdLCByZW1vdGVPcHM6IEZpbGVPcFJlY29yZFtdfT4ge1xuXHRcdFx0Y29uc3Qge2FkZFRvTG9jYWwsIGRlbGV0ZUZyb21Mb2NhbH0gPSBhd2FpdCB0aGlzLmZpdFB1bGwucHJlcGFyZUNoYW5nZXNUb0V4ZWN1dGUoXG5cdFx0XHRcdHJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzKVxuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiVXBsb2FkaW5nIGxvY2FsIGNoYW5nZXNcIilcblx0XHRcdGNvbnN0IHJlbW90ZVRyZWUgPSBhd2FpdCB0aGlzLmZpdC5nZXRUcmVlKGxvY2FsVXBkYXRlLnBhcmVudENvbW1pdFNoYSlcblx0XHRcdGNvbnN0IGNyZWF0ZUNvbW1pdFJlc3VsdCA9IGF3YWl0IHRoaXMuZml0UHVzaC5jcmVhdGVDb21taXRGcm9tTG9jYWxVcGRhdGUobG9jYWxVcGRhdGUsIHJlbW90ZVRyZWUpXG5cdFx0XHRsZXQgbGF0ZXN0UmVtb3RlVHJlZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblx0XHRcdGxldCBsYXRlc3RDb21taXRTaGE6IHN0cmluZztcblx0XHRcdGxldCBwdXNoZWRDaGFuZ2VzOiBBcnJheTxMb2NhbENoYW5nZT47XG5cdFx0XHRpZiAoY3JlYXRlQ29tbWl0UmVzdWx0KSB7XG5cdFx0XHRcdGNvbnN0IHtjcmVhdGVkQ29tbWl0U2hhfSA9IGNyZWF0ZUNvbW1pdFJlc3VsdFxuXHRcdFx0XHRjb25zdCBsYXRlc3RSZWZTaGEgPSBhd2FpdCB0aGlzLmZpdC51cGRhdGVSZWYoY3JlYXRlZENvbW1pdFNoYSlcblx0XHRcdFx0bGF0ZXN0UmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEobGF0ZXN0UmVmU2hhKVxuXHRcdFx0XHRsYXRlc3RDb21taXRTaGEgPSBjcmVhdGVkQ29tbWl0U2hhXG5cdFx0XHRcdHB1c2hlZENoYW5nZXMgPSBjcmVhdGVDb21taXRSZXN1bHQucHVzaGVkQ2hhbmdlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGF0ZXN0UmVtb3RlVHJlZVNoYSA9IHJlbW90ZVVwZGF0ZS5yZW1vdGVUcmVlU2hhXG5cdFx0XHRcdGxhdGVzdENvbW1pdFNoYSA9IHJlbW90ZVVwZGF0ZS5sYXRlc3RSZW1vdGVDb21taXRTaGFcblx0XHRcdFx0cHVzaGVkQ2hhbmdlcyA9IFtdXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIldyaXRpbmcgcmVtb3RlIGNoYW5nZXMgdG8gbG9jYWxcIilcblx0XHRcdGNvbnN0IGxvY2FsRmlsZU9wc1JlY29yZCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudXBkYXRlTG9jYWxGaWxlcyhhZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWwpXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2soe1xuXHRcdFx0XHRsYXN0RmV0Y2hlZFJlbW90ZVNoYTogbGF0ZXN0UmVtb3RlVHJlZVNoYSwgXG5cdFx0XHRcdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBsYXRlc3RDb21taXRTaGEsXG5cdFx0XHRcdGxvY2FsU2hhOiBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuXHRcdFx0fSlcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuICAgICAgICAgICAgcmV0dXJuIHtsb2NhbE9wczogbG9jYWxGaWxlT3BzUmVjb3JkLCByZW1vdGVPcHM6IHB1c2hlZENoYW5nZXN9XG4gICAgfVxuXG5cbiAgICBhc3luYyBzeW5jV2l0aENvbmZsaWN0cyhcbiAgICAgICAgbG9jYWxDaGFuZ2VzOiBMb2NhbENoYW5nZVtdLFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSwgXG4gICAgICAgIHN5bmNOb3RpY2U6IEZpdE5vdGljZSkgOiBQcm9taXNlPHt1bnJlc29sdmVkRmlsZXM6IENsYXNoU3RhdHVzW10sIGxvY2FsT3BzOiBMb2NhbENoYW5nZVtdLCByZW1vdGVPcHM6IExvY2FsQ2hhbmdlW119IHwgbnVsbD4ge1xuICAgICAgICBjb25zdCB7bGF0ZXN0UmVtb3RlQ29tbWl0U2hhLCBjbGFzaGVkRmlsZXMsIHJlbW90ZVRyZWVTaGE6IGxhdGVzdFJlbW90ZVRyZWVTaGF9ID0gcmVtb3RlVXBkYXRlXG5cdFx0XHRjb25zdCB7bm9Db25mbGljdCwgdW5yZXNvbHZlZEZpbGVzLCBmaWxlT3BzUmVjb3JkfSA9IGF3YWl0IHRoaXMucmVzb2x2ZUNvbmZsaWN0cyhjbGFzaGVkRmlsZXMsIGxhdGVzdFJlbW90ZVRyZWVTaGEpXG4gICAgICAgICAgICBsZXQgbG9jYWxDaGFuZ2VzVG9QdXNoOiBBcnJheTxMb2NhbENoYW5nZT47XG4gICAgICAgICAgICBsZXQgcmVtb3RlQ2hhbmdlc1RvV3JpdGU6IEFycmF5PFJlbW90ZUNoYW5nZT5cblx0XHRcdGlmIChub0NvbmZsaWN0KSB7XG5cdFx0XHRcdC8vIG5vIGNvbmZsaWN0IGRldGVjdGVkIGFtb25nIGNsYXNoZWQgZmlsZXMsIGp1c3QgcHVsbCBjaGFuZ2VzIG9ubHkgbWFkZSBvbiByZW1vdGUgYW5kIHB1c2ggY2hhbmdlcyBvbmx5IG1hZGUgb24gbG9jYWxcbiAgICAgICAgICAgICAgICByZW1vdGVDaGFuZ2VzVG9Xcml0ZSA9IHJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzLmZpbHRlcihjID0+ICFsb2NhbENoYW5nZXMuc29tZShsID0+IGwucGF0aCA9PT0gYy5wYXRoKSlcbiAgICAgICAgICAgICAgICBsb2NhbENoYW5nZXNUb1B1c2ggPSBsb2NhbENoYW5nZXMuZmlsdGVyKGMgPT4gIXJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzLnNvbWUociA9PiByLnBhdGggPT09IGMucGF0aCkpXG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgQ2hhbmdlIGNvbmZsaWN0cyBkZXRlY3RlZGApXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IG1vZGlmeSB1bnJlc29sdmVkIGZpbGVzIGxvY2FsbHlcbiAgICAgICAgICAgICAgICByZW1vdGVDaGFuZ2VzVG9Xcml0ZSA9IHJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzLmZpbHRlcihjID0+ICF1bnJlc29sdmVkRmlsZXMuc29tZShsID0+IGwucGF0aCA9PT0gYy5wYXRoKSlcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGNoYW5nZSBldmVuIGlmIHRoZXkgYXJlIGluIHVucmVzb2x2ZWQgZmlsZXMsIHNvIHJlbW90ZSBoYXMgYSByZWNvcmQgb2YgdGhlbSwgXG4gICAgICAgICAgICAgICAgLy8gc28gdXNlciBjYW4gcmVzb2x2ZSBsYXRlciBieSBtb2RpZnlpbmcgbG9jYWwgYW5kIHB1c2ggYWdhaW5cbiAgICAgICAgICAgICAgICBsb2NhbENoYW5nZXNUb1B1c2ggPSBsb2NhbENoYW5nZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHthZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWx9ID0gYXdhaXQgdGhpcy5maXRQdWxsLnByZXBhcmVDaGFuZ2VzVG9FeGVjdXRlKHJlbW90ZUNoYW5nZXNUb1dyaXRlKVxuICAgICAgICAgICAgY29uc3Qgc3luY0xvY2FsVXBkYXRlID0ge1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hhbmdlczogbG9jYWxDaGFuZ2VzVG9QdXNoLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbW1pdFNoYTogbGF0ZXN0UmVtb3RlQ29tbWl0U2hhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwdXNoUmVzdWx0ID0gYXdhaXQgdGhpcy5maXRQdXNoLnB1c2hDaGFuZ2VkRmlsZXNUb1JlbW90ZShzeW5jTG9jYWxVcGRhdGUpXG4gICAgICAgICAgICBsZXQgcHVzaGVkQ2hhbmdlczogTG9jYWxDaGFuZ2VbXTtcbiAgICAgICAgICAgIGxldCBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nO1xuICAgICAgICAgICAgbGV0IGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgICAgICAgaWYgKHB1c2hSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBwdXNoZWRDaGFuZ2VzID0gcHVzaFJlc3VsdC5wdXNoZWRDaGFuZ2VzXG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGEgPSBwdXNoUmVzdWx0Lmxhc3RGZXRjaGVkQ29tbWl0U2hhXG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGEgPSBwdXNoUmVzdWx0Lmxhc3RGZXRjaGVkUmVtb3RlU2hhXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRpZCBub3QgcHVzaCBhbnkgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHB1c2hlZENoYW5nZXMgPSBbXVxuICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhID0gcmVtb3RlVXBkYXRlLmxhdGVzdFJlbW90ZUNvbW1pdFNoYVxuICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhID0gcmVtb3RlVXBkYXRlLnJlbW90ZVRyZWVTaGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsRmlsZU9wc1JlY29yZCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudXBkYXRlTG9jYWxGaWxlcyhhZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWwpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhLCBcbiAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYSxcbiAgICAgICAgICAgICAgICBsb2NhbFNoYTogYXdhaXQgdGhpcy5maXQuY29tcHV0ZUxvY2FsU2hhKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBjb25zdCBvcHMgPSBsb2NhbEZpbGVPcHNSZWNvcmQuY29uY2F0KGZpbGVPcHNSZWNvcmQpXG4gICAgICAgICAgICBpZiAodW5yZXNvbHZlZEZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgU3luYyBzdWNjZXNzZnVsYClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5yZXNvbHZlZEZpbGVzLnNvbWUoZiA9PiBmLnJlbW90ZVN0YXR1cyAhPT0gXCJSRU1PVkVEXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHVzZXIga25vd3MgcmVtb3RlIGZpbGUgY2hhbmdlcyBoYXZlIGJlZW4gd3JpdHRlbiB0byBfZml0IGlmIG5vbi1kZWxldGlvbiBjaGFuZ2Ugb24gcmVtb3RlIGNsYXNoZWQgd2l0aCBsb2NhbCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKGBTeW5jZWQgd2l0aCByZW1vdGUsIHVucmVzb2x2ZWQgY29uZmxpY3RzIHdyaXR0ZW4gdG8gX2ZpdGApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgU3luY2VkIHdpdGggcmVtb3RlLCBpZ25vcmVkIHJlbW90ZSBkZWxldGlvbiBvZiBsb2NhbGx5IGNoYW5nZWQgZmlsZXNgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt1bnJlc29sdmVkRmlsZXMsIGxvY2FsT3BzOiBvcHMsIHJlbW90ZU9wczogcHVzaGVkQ2hhbmdlc31cbiAgICB9XG5cbiAgICBhc3luYyBzeW5jKHN5bmNOb3RpY2U6IEZpdE5vdGljZSk6IFByb21pc2U8e29wczogQXJyYXk8e2hlYWRpbmc6IHN0cmluZywgb3BzOiBGaWxlT3BSZWNvcmRbXX0+LCBjbGFzaDogQ2xhc2hTdGF0dXNbXX0gfCB2b2lkPiB7XG4gICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlBlcmZvcm1pbmcgcHJlIHN5bmMgY2hlY2tzLlwiKVxuXHRcdGNvbnN0IHByZVN5bmNDaGVja1Jlc3VsdCA9IGF3YWl0IHRoaXMucGVyZm9ybVByZVN5bmNDaGVja3MoKTtcblxuICAgICAgICAvLyBjb252ZXJ0IHRvIHN3aXRjaCBzdGF0ZW1lbnQgbGF0ZXIgb24gZm9yIGJldHRlciBtYWludGFpbmFiaWxpdHlcblx0XHRpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJpblN5bmNcIikge1xuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiU3luYyBzdWNjZXNzZnVsXCIpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJvbmx5UmVtb3RlQ29tbWl0U2hhQ2hhbmdlZFwiKSB7XG5cdFx0XHRjb25zdCB7IGxhdGVzdFJlbW90ZUNvbW1pdFNoYSB9ID0gcHJlU3luY0NoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKHtsYXN0RmV0Y2hlZENvbW1pdFNoYTogbGF0ZXN0UmVtb3RlQ29tbWl0U2hhfSlcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVtb3RlVXBkYXRlID0gcHJlU3luY0NoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuXHRcdGlmIChwcmVTeW5jQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcIm9ubHlSZW1vdGVDaGFuZ2VkXCIpIHtcblx0XHRcdGNvbnN0IGZpbGVPcHNSZWNvcmQgPSBhd2FpdCB0aGlzLmZpdFB1bGwucHVsbFJlbW90ZVRvTG9jYWwocmVtb3RlVXBkYXRlLCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2spXG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcbiAgICAgICAgICAgIHJldHVybiB7b3BzOiBbe2hlYWRpbmc6IFwiTG9jYWwgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IGZpbGVPcHNSZWNvcmR9XSwgY2xhc2g6IFtdfVxuXHRcdH1cblxuXHRcdGNvbnN0IHtsb2NhbENoYW5nZXMsIGxvY2FsVHJlZVNoYX0gPSBwcmVTeW5jQ2hlY2tSZXN1bHRcblx0XHRjb25zdCBsb2NhbFVwZGF0ZSA9IHtcblx0XHRcdGxvY2FsQ2hhbmdlcyxcblx0XHRcdHBhcmVudENvbW1pdFNoYTogcmVtb3RlVXBkYXRlLmxhdGVzdFJlbW90ZUNvbW1pdFNoYVxuXHRcdH1cblx0XHRpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJvbmx5TG9jYWxDaGFuZ2VkXCIpIHtcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlVwbG9hZGluZyBsb2NhbCBjaGFuZ2VzXCIpXG5cdFx0XHRjb25zdCBwdXNoUmVzdWx0ID0gYXdhaXQgdGhpcy5maXRQdXNoLnB1c2hDaGFuZ2VkRmlsZXNUb1JlbW90ZShsb2NhbFVwZGF0ZSlcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuICAgICAgICAgICAgaWYgKHB1c2hSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNoYTogbG9jYWxUcmVlU2hhLFxuICAgICAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogcHVzaFJlc3VsdC5sYXN0RmV0Y2hlZFJlbW90ZVNoYSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IHB1c2hSZXN1bHQubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHJldHVybiB7b3BzOiBbe2hlYWRpbmc6IFwiTG9jYWwgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IHB1c2hSZXN1bHQucHVzaGVkQ2hhbmdlc31dLCBjbGFzaDogW119XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0Ly8gZG8gYm90aCBwdWxsIGFuZCBwdXNoIChvcmRlcnMgb2YgZXhlY3V0aW9uIGRpZmZlcmVudCBmcm9tIHB1bGxSZW1vdGVUb0xvY2FsIGFuZCBcblx0XHQvLyBwdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUgdG8gbWFrZSB0aGlzIG1vcmUgdHJhbnNhY3Rpb24gbGlrZSwgaS5lLiBtYWludGFpbiBvcmlnaW5hbCBcblx0XHQvLyBzdGF0ZSBpZiB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkKSBJZiB5b3UgaGF2ZSBpZGVhcyBvbiBob3cgdG8gbWFrZSB0aGlzIG1vcmUgdHJhbnNhY3Rpb24tbGlrZSxcblx0XHQvLyAgcGxlYXNlIG9wZW4gYW4gaXNzdWUgb24gdGhlIGZpdCByZXBvXG5cdFx0aWYgKHByZVN5bmNDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwibG9jYWxBbmRSZW1vdGVDaGFuZ2VzQ29tcGF0aWJsZVwiKSB7XG5cdFx0XHRjb25zdCB7bG9jYWxPcHMsIHJlbW90ZU9wc30gPSBhd2FpdCB0aGlzLnN5bmNDb21wYXRpYmxlQ2hhbmdlcyhcblx0XHRcdFx0bG9jYWxVcGRhdGUsIHJlbW90ZVVwZGF0ZSwgc3luY05vdGljZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZzogXCJMb2NhbCBmaWxlIHVwZGF0ZXM6XCIsIG9wczogbG9jYWxPcHN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRpbmc6IFwiUmVtb3RlIGZpbGUgdXBkYXRlczpcIiwgb3BzOiByZW1vdGVPcHN9LFxuICAgICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICAgICAgY2xhc2g6IFtdXG4gICAgICAgICAgICAgICAgfSlcblx0XHR9XG5cblx0XHRpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDbGFzaGVkXCIpIHtcblx0XHRcdGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY1dpdGhDb25mbGljdHMoXG5cdFx0XHRcdGxvY2FsVXBkYXRlLmxvY2FsQ2hhbmdlcywgcmVtb3RlVXBkYXRlLCBzeW5jTm90aWNlKVxuXHRcdFx0aWYgKGNvbmZsaWN0UmVzb2x1dGlvblJlc3VsdCkge1xuXHRcdFx0XHRjb25zdCB7dW5yZXNvbHZlZEZpbGVzLCBsb2NhbE9wcywgcmVtb3RlT3BzfSA9IGNvbmZsaWN0UmVzb2x1dGlvblJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczpbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRpbmc6IFwiTG9jYWwgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IGxvY2FsT3BzfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZzogXCJSZW1vdGUgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IHJlbW90ZU9wc30sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc2g6IHVucmVzb2x2ZWRGaWxlc1xuICAgICAgICAgICAgICAgICAgICB9KVxuXHRcdFx0fVxuXHRcdH1cbiAgICB9XG59IiwgImltcG9ydCB7IEZpdCB9IGZyb20gXCIuL2ZpdFwiO1xuaW1wb3J0IHsgTG9jYWxTdG9yZXMgfSBmcm9tIFwibWFpblwiO1xuaW1wb3J0IHsgRmlsZU9wUmVjb3JkLCBMb2NhbENoYW5nZSwgUmVtb3RlQ2hhbmdlLCBSZW1vdGVVcGRhdGUgfSBmcm9tIFwiLi9maXRUeXBlc1wiO1xuXG50eXBlIFByZVB1bGxDaGVja1Jlc3VsdFR5cGUgPSAoXG4gICAgXCJsb2NhbENvcHlVcFRvRGF0ZVwiIHwgXG4gICAgXCJsb2NhbENoYW5nZXNDbGFzaFdpdGhSZW1vdGVDaGFuZ2VzXCIgfCBcbiAgICBcInJlbW90ZUNoYW5nZXNDYW5CZU1lcmdlZFwiIHwgXG4gICAgXCJub1JlbW90ZUNoYW5nZXNEZXRlY3RlZFwiXG4pXG5cbnR5cGUgUHJlUHVsbENoZWNrUmVzdWx0ID0gKFxuICAgIHsgc3RhdHVzOiBcImxvY2FsQ29weVVwVG9EYXRlXCIsIHJlbW90ZVVwZGF0ZTogbnVsbCB9IHwgXG4gICAgeyBzdGF0dXM6IEV4Y2x1ZGU8UHJlUHVsbENoZWNrUmVzdWx0VHlwZSwgXCJsb2NhbENvcHlVcFRvRGF0ZVwiPiwgcmVtb3RlVXBkYXRlOiBSZW1vdGVVcGRhdGUgfVxuKTtcblxuZXhwb3J0IGludGVyZmFjZSBJRml0UHVsbCB7XG4gICAgZml0OiBGaXRcbn1cblxuZXhwb3J0IGNsYXNzIEZpdFB1bGwgaW1wbGVtZW50cyBJRml0UHVsbCB7XG4gICAgZml0OiBGaXRcbiAgICBcblxuICAgIGNvbnN0cnVjdG9yKGZpdDogRml0KSB7XG4gICAgICAgIHRoaXMuZml0ID0gZml0XG4gICAgfVxuXG4gICAgYXN5bmMgcGVyZm9ybVByZVB1bGxDaGVja3MobG9jYWxDaGFuZ2VzPzogTG9jYWxDaGFuZ2VbXSk6IFByb21pc2U8UHJlUHVsbENoZWNrUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHtyZW1vdGVDb21taXRTaGEsIHVwZGF0ZWR9ID0gYXdhaXQgdGhpcy5maXQucmVtb3RlVXBkYXRlZCgpXG4gICAgICAgIGlmICghdXBkYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6IFwibG9jYWxDb3B5VXBUb0RhdGVcIiwgcmVtb3RlVXBkYXRlOiBudWxsfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbG9jYWxDaGFuZ2VzKSB7XG4gICAgICAgICAgICBsb2NhbENoYW5nZXMgPSBhd2FpdCB0aGlzLmZpdC5nZXRMb2NhbENoYW5nZXMoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKHJlbW90ZUNvbW1pdFNoYSlcbiAgICAgICAgY29uc3QgcmVtb3RlQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZUNoYW5nZXMocmVtb3RlVHJlZVNoYSlcbiAgICAgICAgY29uc3QgY2xhc2hlZEZpbGVzID0gdGhpcy5maXQuZ2V0Q2xhc2hlZENoYW5nZXMobG9jYWxDaGFuZ2VzLCByZW1vdGVDaGFuZ2VzKVxuICAgICAgICAvLyBUT0RPIGhhbmRsZSBjbGFzaGVzIHdpdGhvdXQgY29tcGxldGVseSBibG9ja2luZyBwdWxsXG4gICAgICAgIGNvbnN0IHByZVB1bGxDaGVja1N0YXR1cyA9IChcbiAgICAgICAgICAgIChyZW1vdGVDaGFuZ2VzLmxlbmd0aCA+IDApID8gKFxuICAgICAgICAgICAgICAgIChjbGFzaGVkRmlsZXMubGVuZ3RoID4gMCkgPyBcImxvY2FsQ2hhbmdlc0NsYXNoV2l0aFJlbW90ZUNoYW5nZXNcIiA6IFwicmVtb3RlQ2hhbmdlc0NhbkJlTWVyZ2VkXCIpOlxuICAgICAgICAgICAgICAgIFwibm9SZW1vdGVDaGFuZ2VzRGV0ZWN0ZWRcIilcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHByZVB1bGxDaGVja1N0YXR1cywgXG4gICAgICAgICAgICByZW1vdGVVcGRhdGU6IHtcbiAgICAgICAgICAgICAgICByZW1vdGVDaGFuZ2VzLCByZW1vdGVUcmVlU2hhLCBsYXRlc3RSZW1vdGVDb21taXRTaGE6IHJlbW90ZUNvbW1pdFNoYSwgY2xhc2hlZEZpbGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgY2hhbmdlcyBmcm9tIHJlbW90ZSwgcGF0aFNoYU1hcCBpcyBjb3VwbGVkIHRvIHRoZSBGaXQgcGx1Z2luIGRlc2lnblxuICAgIGFzeW5jIGdldFJlbW90ZU5vbkRlbGV0aW9uQ2hhbmdlc0NvbnRlbnQocGF0aFNoYU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gT2JqZWN0LmVudHJpZXMocGF0aFNoYU1hcCkubWFwKGFzeW5jIChbcGF0aCwgZmlsZV9zaGFdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5maXQuZ2V0QmxvYihmaWxlX3NoYSk7XG4gICAgICAgICAgICByZXR1cm4ge3BhdGgsIGNvbnRlbnR9O1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocmVtb3RlQ2hhbmdlcylcbiAgICB9XG5cbiAgICBhc3luYyBwcmVwYXJlQ2hhbmdlc1RvRXhlY3V0ZShyZW1vdGVDaGFuZ2VzOiBSZW1vdGVDaGFuZ2VbXSkge1xuICAgICAgICBjb25zdCBkZWxldGVGcm9tTG9jYWwgPSByZW1vdGVDaGFuZ2VzLmZpbHRlcihjPT5jLnN0YXR1cz09XCJSRU1PVkVEXCIpLm1hcChjPT5jLnBhdGgpXG5cdFx0XHRjb25zdCBjaGFuZ2VzVG9Qcm9jZXNzID0gcmVtb3RlQ2hhbmdlcy5maWx0ZXIoYz0+Yy5zdGF0dXMhPVwiUkVNT1ZFRFwiKS5yZWR1Y2UoXG5cdFx0XHRcdChhY2MsIGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY2NbY2hhbmdlLnBhdGhdID0gY2hhbmdlLmN1cnJlbnRTaGEgYXMgc3RyaW5nO1xuXHRcdFx0XHRcdHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPik7XG5cblx0XHRjb25zdCBhZGRUb0xvY2FsID0gYXdhaXQgdGhpcy5nZXRSZW1vdGVOb25EZWxldGlvbkNoYW5nZXNDb250ZW50KGNoYW5nZXNUb1Byb2Nlc3MpXG4gICAgICAgIHJldHVybiB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfVxuICAgIH1cblxuICAgIGFzeW5jIHB1bGxSZW1vdGVUb0xvY2FsKFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSxcbiAgICAgICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjazogKGxvY2FsU3RvcmU6IFBhcnRpYWw8TG9jYWxTdG9yZXM+KSA9PiBQcm9taXNlPHZvaWQ+KTogUHJvbWlzZTxGaWxlT3BSZWNvcmRbXT4ge1xuICAgICAgICAgICAgY29uc3Qge3JlbW90ZUNoYW5nZXMsIHJlbW90ZVRyZWVTaGEsIGxhdGVzdFJlbW90ZUNvbW1pdFNoYX0gPSByZW1vdGVVcGRhdGVcbiAgICAgICAgICAgIGNvbnN0IHthZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWx9ID0gYXdhaXQgdGhpcy5wcmVwYXJlQ2hhbmdlc1RvRXhlY3V0ZShyZW1vdGVDaGFuZ2VzKVxuXHRcdFx0XG5cdFx0XHRjb25zdCBmaWxlT3BzUmVjb3JkID0gYXdhaXQgdGhpcy5maXQudmF1bHRPcHMudXBkYXRlTG9jYWxGaWxlcyhhZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWwpO1xuXHRcdFx0YXdhaXQgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IHJlbW90ZVRyZWVTaGEsIFxuICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBsYXRlc3RSZW1vdGVDb21taXRTaGEsXG4gICAgICAgICAgICAgICAgbG9jYWxTaGE6IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVPcHNSZWNvcmRcbiAgICB9XG59IiwgImltcG9ydCB7IEZpdCwgVHJlZU5vZGUgfSBmcm9tIFwiLi9maXRcIjtcbmltcG9ydCB7IExvY2FsQ2hhbmdlLCBMb2NhbFVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBJRml0UHVzaCB7XG4gICAgbG9jYWxTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBmaXQ6IEZpdFxufVxuXG5leHBvcnQgY2xhc3MgRml0UHVzaCBpbXBsZW1lbnRzIElGaXRQdXNoIHtcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBmaXQ6IEZpdFxuICAgIFxuXG4gICAgY29uc3RydWN0b3IoZml0OiBGaXQpIHtcbiAgICAgICAgdGhpcy5maXQgPSBmaXRcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVDb21taXRGcm9tTG9jYWxVcGRhdGUobG9jYWxVcGRhdGU6IExvY2FsVXBkYXRlLCByZW1vdGVUcmVlOiBBcnJheTxUcmVlTm9kZT4pOiBQcm9taXNlPHtjcmVhdGVkQ29tbWl0U2hhOiBzdHJpbmcsIHB1c2hlZENoYW5nZXM6IExvY2FsQ2hhbmdlW119IHwgbnVsbD4ge1xuICAgICAgICBjb25zdCB7bG9jYWxDaGFuZ2VzLCBwYXJlbnRDb21taXRTaGF9ID0gbG9jYWxVcGRhdGVcbiAgICAgICAgY29uc3QgcHVzaGVkQ2hhbmdlczogTG9jYWxDaGFuZ2VbXSA9IFtdO1xuICAgICAgICBjb25zdCB0cmVlTm9kZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwobG9jYWxDaGFuZ2VzLm1hcChhc3luYyAoZiwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9ICBhd2FpdCB0aGlzLmZpdC5jcmVhdGVUcmVlTm9kZUZyb21GaWxlKGYsIHJlbW90ZVRyZWUpXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHB1c2hlZENoYW5nZXMucHVzaChsb2NhbENoYW5nZXNbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpKS5maWx0ZXIoQm9vbGVhbikgYXMgQXJyYXk8VHJlZU5vZGU+XG4gICAgICAgIGNvbnNvbGUubG9nKHRyZWVOb2RlcylcbiAgICAgICAgaWYgKHRyZWVOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF0ZXN0UmVtb3RlQ29tbWl0VHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldENvbW1pdFRyZWVTaGEocGFyZW50Q29tbWl0U2hhKVxuICAgICAgICBjb25zdCBjcmVhdGVkVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmNyZWF0ZVRyZWUodHJlZU5vZGVzLCBsYXRlc3RSZW1vdGVDb21taXRUcmVlU2hhKVxuICAgICAgICBjb25zdCBjcmVhdGVkQ29tbWl0U2hhID0gYXdhaXQgdGhpcy5maXQuY3JlYXRlQ29tbWl0KGNyZWF0ZWRUcmVlU2hhLCBwYXJlbnRDb21taXRTaGEpXG4gICAgICAgIHJldHVybiB7Y3JlYXRlZENvbW1pdFNoYSwgcHVzaGVkQ2hhbmdlc31cbiAgICB9XG5cblxuXG4gICAgYXN5bmMgcHVzaENoYW5nZWRGaWxlc1RvUmVtb3RlKFxuICAgICAgICBsb2NhbFVwZGF0ZTogTG9jYWxVcGRhdGUsXG4gICAgICAgICk6IFByb21pc2U8e3B1c2hlZENoYW5nZXM6IExvY2FsQ2hhbmdlW10sIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nfXxudWxsPiB7XG4gICAgICAgICAgICBpZiAobG9jYWxVcGRhdGUubG9jYWxDaGFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlkIG5vdCB1cGRhdGUgcmVmXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0IHtsb2NhbFRyZWVTaGF9ID0gbG9jYWxVcGRhdGU7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVUcmVlID0gYXdhaXQgdGhpcy5maXQuZ2V0VHJlZShsb2NhbFVwZGF0ZS5wYXJlbnRDb21taXRTaGEpXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVDb21taXRSZXN1bHQgPSBhd2FpdCB0aGlzLmNyZWF0ZUNvbW1pdEZyb21Mb2NhbFVwZGF0ZShsb2NhbFVwZGF0ZSwgcmVtb3RlVHJlZSlcbiAgICAgICAgICAgIGlmICghY3JlYXRlQ29tbWl0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gZGlkIG5vdCB1cGRhdGUgcmVmXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHtjcmVhdGVkQ29tbWl0U2hhLCBwdXNoZWRDaGFuZ2VzfSA9IGNyZWF0ZUNvbW1pdFJlc3VsdFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFJlZlNoYSA9IGF3YWl0IHRoaXMuZml0LnVwZGF0ZVJlZihjcmVhdGVkQ29tbWl0U2hhKVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKHVwZGF0ZWRSZWZTaGEpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHB1c2hlZENoYW5nZXMsIFxuICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiB1cGRhdGVkUmVtb3RlVHJlZVNoYSwgXG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IGNyZWF0ZWRDb21taXRTaGEsXG4gICAgICAgICAgICB9XG4gICAgfVxufSIsICJpbXBvcnQgeyBURmlsZSwgVmF1bHQsIGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IEZpbGVPcFJlY29yZCB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBJVmF1bHRPcGVyYXRpb25zIHtcbiAgICB2YXVsdDogVmF1bHRcbiAgICBkZWxldGVGcm9tTG9jYWw6IChwYXRoOiBzdHJpbmcpID0+IFByb21pc2U8RmlsZU9wUmVjb3JkPlxuICAgIHdyaXRlVG9Mb2NhbDogKHBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiBQcm9taXNlPEZpbGVPcFJlY29yZD5cbiAgICB1cGRhdGVMb2NhbEZpbGVzOiAoXG4gICAgICAgIGFkZFRvTG9jYWw6IHtwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ31bXSwgZGVsZXRlRnJvbUxvY2FsOiBBcnJheTxzdHJpbmc+KSBcbiAgICAgICAgPT4gUHJvbWlzZTxGaWxlT3BSZWNvcmRbXT5cbiAgICBjcmVhdGVDb3B5SW5EaXI6IChwYXRoOiBzdHJpbmcsIGNvcHlEaXI6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPlxufVxuXG5leHBvcnQgY2xhc3MgVmF1bHRPcGVyYXRpb25zIGltcGxlbWVudHMgSVZhdWx0T3BlcmF0aW9ucyB7XG4gICAgdmF1bHQ6IFZhdWx0XG5cbiAgICBjb25zdHJ1Y3Rvcih2YXVsdDogVmF1bHQpIHtcbiAgICAgICAgdGhpcy52YXVsdCA9IHZhdWx0XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VEZpbGUocGF0aDogc3RyaW5nKTogUHJvbWlzZTxURmlsZT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aClcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0aW5nIHRvIHJlYWQgJHtwYXRofSBmcm9tIGxvY2FsIGRyaXZlIGFzIFRGaWxlIGJ1dCBub3Qgc3VjY2Vzc2Z1bCxcbiAgICAgICAgICAgIGZpbGUgaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfS5gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlRnJvbUxvY2FsKHBhdGg6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkPiB7XG4gICAgICAgIC8vIGFkb3B0ZWQgZ2V0QWJzdHJhY3RGaWxlQnlQYXRoIGZvciBtb2JpbGUgY29tcGF0aWFiaWxpdHlcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGgpXG4gICAgICAgIGlmIChmaWxlICYmIGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5kZWxldGUoZmlsZSk7XG4gICAgICAgICAgICByZXR1cm4ge3BhdGgsIHN0YXR1czogXCJkZWxldGVkXCJ9XG4gICAgICAgIH0gXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGluZyB0byBkZWxldGUgJHtwYXRofSBmcm9tIGxvY2FsIGJ1dCBub3Qgc3VjY2Vzc2Z1bCwgZmlsZSBpcyBvZiB0eXBlICR7dHlwZW9mIGZpbGV9LmApO1xuICAgIH1cblxuICAgIC8vIGlmIGNoZWNraW5nIGEgZm9sZGVyLCByZXF1aXJlIGluY2x1ZGluZyB0aGUgbGFzdCAvIGluIHRoZSBwYXRoIHBhcmFtXG4gICAgYXN5bmMgZW5zdXJlRm9sZGVyRXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBleHRyYWN0IGZvbGRlciBwYXRoLCByZXR1cm4gZW1wdHkgc3RyaW5nIGlzIG5vIGZvbGRlciBwYXRoIGlzIG1hdGNoZWQgKGV4Y2x1ZGUgdGhlIGxhc3QgLylcbiAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IHBhdGgubWF0Y2goL14oLiopXFwvLyk/LlsxXSB8fCAnJztcbiAgICAgICAgaWYgKGZvbGRlclBhdGggIT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aClcbiAgICAgICAgICAgIGlmICghZm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5jcmVhdGVGb2xkZXIoZm9sZGVyUGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHdyaXRlVG9Mb2NhbChwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkPiB7XG4gICAgICAgIC8vIGFkb3B0ZWQgZ2V0QWJzdHJhY3RGaWxlQnlQYXRoIGZvciBtb2JpbGUgY29tcGF0aWFiaWxpdHlcbiAgICAgICAgLy8gVE9ETzogYWRkIGNhcGFiaWxpdHkgZm9yIGNyZWF0aW5nIGZvbGRlciBmcm9tIHJlbW90ZVxuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aClcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeUJpbmFyeShmaWxlLCBiYXNlNjRUb0FycmF5QnVmZmVyKGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiY2hhbmdlZFwifVxuICAgICAgICB9IGVsc2UgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUZvbGRlckV4aXN0cyhwYXRoKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5jcmVhdGVCaW5hcnkocGF0aCwgYmFzZTY0VG9BcnJheUJ1ZmZlcihjb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiB7cGF0aCwgc3RhdHVzOiBcImNyZWF0ZWRcIn1cbiAgICAgICAgfSBcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtwYXRofSB3cml0ZVRvTG9jYWwgb3BlcmF0aW9uIHVuc3VjY2Vzc2Z1bCwgdmF1bHQgYWJzdHJhY3RGaWxlIG9uICR7cGF0aH0gaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfWApO1xuICAgIH1cblxuICAgIGFzeW5jIHVwZGF0ZUxvY2FsRmlsZXMoXG4gICAgICAgIGFkZFRvTG9jYWw6IHtwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ31bXSwgXG4gICAgICAgIGRlbGV0ZUZyb21Mb2NhbDogQXJyYXk8c3RyaW5nPik6IFByb21pc2U8RmlsZU9wUmVjb3JkW10+IHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgZmlsZSBhZGRpdGlvbnMgb3IgdXBkYXRlc1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVPcGVyYXRpb25zID0gYWRkVG9Mb2NhbC5tYXAoYXN5bmMgKHtwYXRoLCBjb250ZW50fSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndyaXRlVG9Mb2NhbChwYXRoLCBjb250ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gUHJvY2VzcyBmaWxlIGRlbGV0aW9uc1xuICAgICAgICAgICAgY29uc3QgZGVsZXRpb25PcGVyYXRpb25zID0gZGVsZXRlRnJvbUxvY2FsLm1hcChhc3luYyAocGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZUZyb21Mb2NhbChwYXRoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlT3BzID0gYXdhaXQgUHJvbWlzZS5hbGwoWy4uLndyaXRlT3BlcmF0aW9ucywgLi4uZGVsZXRpb25PcGVyYXRpb25zXSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZU9wc1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUNvcHlJbkRpcihwYXRoOiBzdHJpbmcsIGNvcHlEaXIgPSBcIl9maXRcIik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aClcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkQmluYXJ5KGZpbGUpXG4gICAgICAgICAgICBjb25zdCBjb3B5UGF0aCA9IGAke2NvcHlEaXJ9LyR7cGF0aH1gXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUZvbGRlckV4aXN0cyhjb3B5UGF0aClcbiAgICAgICAgICAgIGNvbnN0IGNvcHlGaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aClcbiAgICAgICAgICAgIGlmIChjb3B5RmlsZSAmJiBjb3B5RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5tb2RpZnlCaW5hcnkoY29weUZpbGUsIGNvcHkpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjb3B5RmlsZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlQmluYXJ5KGNvcHlQYXRoLCBjb3B5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhdWx0LmRlbGV0ZShjb3B5RmlsZSwgdHJ1ZSkgLy8gVE9ETyBhZGQgd2FybmluZyB0byBsZXQgdXNlciBrbm93IGZpbGVzIGluIF9maXQgd2lsbCBiZSBvdmVyd3JpdHRlblxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlQmluYXJ5KGNvcHlQYXRoLCBjb3B5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5jcmVhdGVCaW5hcnkoY29weVBhdGgsIGNvcHkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gY3JlYXRlIGNvcHkgb2YgJHtwYXRofSBmcm9tIGxvY2FsIGRyaXZlIGFzIFRGaWxlIGJ1dCBub3Qgc3VjY2Vzc2Z1bCxcbiAgICAgICAgICAgIGZpbGUgaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfS5gKVxuICAgICAgICB9XG4gICAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQUFtQzs7O0FDQTVCLFNBQVMsZUFBZTtBQUM3QixNQUFJLE9BQU8sY0FBYyxZQUFZLGVBQWUsV0FBVztBQUM3RCxXQUFPLFVBQVU7QUFBQSxFQUNuQjtBQUVBLE1BQUksT0FBTyxZQUFZLFlBQVksUUFBUSxZQUFZLFFBQVc7QUFDaEUsV0FBTyxXQUFXLFFBQVEsUUFBUSxPQUFPLENBQUMsTUFBTSxRQUFRLGFBQ3RELFFBQVE7QUFBQSxFQUVaO0FBRUEsU0FBTztBQUNUOzs7QUNWTyxTQUFTLFNBQVMsT0FBTyxNQUFNLFFBQVEsU0FBUztBQUNyRCxNQUFJLE9BQU8sV0FBVyxZQUFZO0FBQ2hDLFVBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUFBLEVBQzdEO0FBRUEsTUFBSSxDQUFDLFNBQVM7QUFDWixjQUFVLENBQUM7QUFBQSxFQUNiO0FBRUEsTUFBSSxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3ZCLFdBQU8sS0FBSyxRQUFRLEVBQUUsT0FBTyxDQUFDLFVBQVVDLFVBQVM7QUFDL0MsYUFBTyxTQUFTLEtBQUssTUFBTSxPQUFPQSxPQUFNLFVBQVUsT0FBTztBQUFBLElBQzNELEdBQUcsTUFBTSxFQUFFO0FBQUEsRUFDYjtBQUVBLFNBQU8sUUFBUSxRQUFRLEVBQUUsS0FBSyxNQUFNO0FBQ2xDLFFBQUksQ0FBQyxNQUFNLFNBQVMsSUFBSSxHQUFHO0FBQ3pCLGFBQU8sT0FBTyxPQUFPO0FBQUEsSUFDdkI7QUFFQSxXQUFPLE1BQU0sU0FBUyxJQUFJLEVBQUUsT0FBTyxDQUFDQyxT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TUFBTSxpQkFBaUI7QUFDdEIsVUFBTSxhQUFhLE9BQU8sT0FBTyxDQUFDLEdBQUcscUJBQXFCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDL0UsVUFBTSxnQkFBNkIsT0FBTyxLQUFLLG1CQUFtQixFQUFFO0FBQUEsTUFDbkUsQ0FBQyxLQUFLLFFBQTJCO0FBQ2hDLFlBQUksV0FBVyxlQUFlLEdBQUcsR0FBRztBQUNuQyxjQUFJLEdBQUcsSUFBSSxXQUFXLEdBQUc7QUFBQSxRQUMxQjtBQUNBLGVBQU87QUFBQSxNQUNSO0FBQUEsTUFBRyxDQUFDO0FBQUEsSUFBZ0I7QUFDckIsU0FBSyxhQUFhO0FBQUEsRUFDbkI7QUFBQTtBQUFBLEVBR0EsTUFBTSxpQkFBaUI7QUFDdEIsVUFBTSxPQUFPLE9BQU8sT0FBTyxDQUFDLEdBQUcscUJBQXFCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDekUsVUFBTSxLQUFLLFNBQVMsRUFBQyxHQUFHLE1BQU0sR0FBRyxLQUFLLFdBQVUsQ0FBQztBQUVqRCxTQUFLLElBQUksZUFBZSxLQUFLLFVBQVU7QUFBQSxFQUN4QztBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sT0FBTyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQ3RFLFVBQU0sS0FBSyxTQUFTLEVBQUMsR0FBRyxNQUFNLEdBQUcsS0FBSyxTQUFRLENBQUM7QUFFL0MsU0FBSyw4QkFBOEI7QUFFbkMsU0FBSyxJQUFJLGFBQWEsS0FBSyxRQUFRO0FBQUEsRUFDcEM7QUFDRDsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgIm5hbWUiLCAibWV0aG9kIiwgImhvb2siLCAiaG9vayIsICJnZXRVc2VyQWdlbnQiLCAiZ2V0VXNlckFnZW50IiwgImdldFVzZXJBZ2VudCIsICJWRVJTSU9OIiwgImlzUGxhaW5PYmplY3QiLCAid2l0aERlZmF1bHRzIiwgImdldFVzZXJBZ2VudCIsICJnZXRVc2VyQWdlbnQiLCAiVkVSU0lPTiIsICJ3aXRoRGVmYXVsdHMiLCAiZ2V0VXNlckFnZW50IiwgInJlcXVlc3QiLCAiZW5kcG9pbnQiLCAiVkVSU0lPTiIsICJWRVJTSU9OIiwgImhvb2siLCAiYXV0aCIsICJoZWFkaW5nIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iXQp9Cg==
